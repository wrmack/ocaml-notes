{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#why-these-notes","title":"Why these notes","text":"<p>There is some excellent documentation aleady available for Ocaml:</p> <ul> <li>the official manual</li> <li>OCaml website learning resources</li> <li>Real World Ocaml</li> <li>OCaml programming textbook</li> <li>Think OCaml</li> <li>Building OCaml Applications from Basic to Advanced Features (tutorial constructed by AI)</li> </ul> <p>However, I only dabble in Ocaml from time so: </p> <ul> <li>I need a quick reference that is more than a cheat sheet</li> <li>I like the adage: to learn something, teach it (in this case, write up some documentation)<sup>1</sup> </li> </ul> <p>These notes reflect personal reactions to learning Ocaml:</p> <ul> <li>prefer examples to signatures (\"don't show me the function signature - show me how I use it\").</li> <li>what does ... mean? When learning, one browses various information sources, such as Stackoverflow or the Ocaml Discord. People refer to advanced concepts and terminology whose meaning is too hard to look up using Google. I have tried to provide a basic glossary to cover this.</li> </ul>"},{"location":"#information-in-boxes","title":"Information in boxes","text":"<p>These notes use the following box types throughout:</p> <p>Examples</p> <p>Code examples</p> <p>Quotes</p> <p>Helpful authoritative quotes</p> <p>Understanding</p> <p>Additional comments to aid understanding</p> <p>References</p> <p>Links to sources</p>"},{"location":"#other-interesting-documentation","title":"Other interesting documentation","text":"<p>Related languages</p> <p>It can help to understand concepts in Ocaml by reading the documentation of related languages</p> F# Derived from Ocaml and used with the .NET framework Haskell A functional programming language Rust A newer language which acknowledges influences from Ocaml SML (Standard ML) Describes Ocaml as a \"close cousin\".  Has an interesting history page. The book Programming in Standard ML has very good explanations. <ol> <li> <p>Also see Richard Feynman's Learning Technique \u21a9</p> </li> </ol>"},{"location":"let/","title":"let","text":""},{"location":"let/#let-pattern-matching","title":"let pattern matching","text":"<p>Ocaml manual</p> <p>The <code>let</code> and <code>let rec</code> constructs bind value names locally. The construct</p> <p><pre><code>let pattern1 = expr1 and \u2026 and patternn = exprn in expr\n</code></pre> evaluates <code>expr1 \u2026 exprn</code> in some unspecified order and matches their values against the patterns <code>pattern1 \u2026 patternn</code>. If the matchings succeed, <code>expr</code> is evaluated in the environment enriched by the bindings performed during matching, and the value of <code>expr</code> is returned as the value of the whole let expression. If one of the matchings fails, the exception <code>Match_failure</code> is raised.</p> <p>Example</p> <pre><code>(* Bind a tuple to a name *)\nlet tup = (1,'b',\"word\")\n\n(* The pattern (x,y,z) matches tup *)\nlet (x,y,z) = tup\n\n(* Can now access elements of the tuple *)\nlet () = Printf.printf \"the second element is %c \\n%!\" y;;\n(* Prints \"the second element is b\" *)\n\n(* In the expression let () = &lt;print statement&gt; \n   the pattern () stands for unit and matches the \n   print statement *)\n</code></pre>"},{"location":"let/#letin","title":"<code>let...in</code>","text":"<ul> <li><code>let name = expression</code> binds an expression to a name</li> <li>'name' cannot be mutated, though it can be redefined (ie with <code>let name =</code>)</li> <li><code>let name = expression1 in expression2</code> defines the scope of 'name' to be within 'expression2'</li> </ul> <p>Examples</p> <pre><code>(* Binds an integer to a name 'x' *)\nlet x = 5;;\n\n(* Binds a function with two parameters to a name - these are equivalent *)\nlet sum x y = x + y;;\nlet sum = (fun x y -&gt; x + y);;\n\n(* Binds an expression to a name, to be used in a defined scope *)\nlet num = 2 in num * 2;;\n\n(* Another example*)\nlet double x = x * 2 in\n let y = double 100 in\n y - 1;;\n\n(* Binds the result of the above to the name 'myresult' *)    \nlet myresult = \n let double x = x * 2 in\n let y = double 100 in\n y - 1;;    \n</code></pre>"},{"location":"let/#let-binding-operators","title":"let binding operators","text":"<p>Ocaml manual</p> <p>Binding operators offer syntactic sugar to expose library functions under (a variant of) the familiar syntax of standard keywords. Currently supported \u201cbinding operators\u201d are <code>let&lt;op&gt;</code> and <code>and&lt;op&gt;</code>, where <code>&lt;op&gt;</code> is an operator symbol, for example <code>and+$</code>.</p> <p>Binding operators were introduced to offer convenient syntax for working with monads and applicative functors; for those, we propose conventions using operators <code>*</code> and <code>+</code> respectively.</p> <p>Meaning of let binding operator</p> <p>An operator in OCaml is defined with the syntax: <pre><code>let ( &lt;op&gt; ) = ...\n\n(* Example - the + infix operator *)\nlet ( + ) = \n</code></pre> let operators</p> <p>The keyword <code>let</code> binds an expression to a name.</p> <p>A let binding operator provides a special syntax using <code>let&lt;op&gt;</code> where <code>&lt;op&gt;</code> is an operator symbol like <code>+</code> or <code>*</code>.</p> <p>The syntax uses the <code>let&lt;op&gt;</code> operator in a similar way to a an ordinary <code>let</code> binding. Hence \"let binding operator\".</p> <p>It is defined like an ordinary operator:</p> <pre><code>let ( let@ ) = \n</code></pre> <p>An <code>and&lt;op&gt;</code> operator can be defined.</p> <p>Desugaring</p> <p>The let-operator in <pre><code>let&lt;op&gt; x1 = e1 in e\n</code></pre> can be desugared into an application <pre><code>( let&lt;op&gt; ) e1 (fun x1 -&gt; e)\n</code></pre> OCaml manual</p> <p>Conventions</p> <p>By convention:</p> <ul> <li>applicative functors use <code>let+</code></li> <li>monad functors use <code>let*</code></li> </ul> <p>An applicative functor should provide a module implementing the following interface: <pre><code>module type Applicative_syntax = sig\n  type 'a t\n  val ( let+ ) : 'a t -&gt; ('a -&gt; 'b) -&gt; 'b t\n  val ( and+ ): 'a t -&gt; 'b t -&gt; ('a * 'b) t\nend\n</code></pre> where <code>(let+)</code> is bound to the map operation and <code>(and+)</code> is bound to the monoidal product operation.</p> <p>A monad should provide a module implementing the following interface: <pre><code>module type Monad_syntax = sig\n  include Applicative_syntax\n  val ( let* ) : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t\n  val ( and* ): 'a t -&gt; 'b t -&gt; ('a * 'b) t\nend\n</code></pre> where <code>(let*)</code> is bound to the bind operation, and <code>(and*)</code> is also bound to the monoidal product operation.</p> <p><code>let ( let@ ) x f = f x</code></p> <pre><code>let (let@) x f = f x;;\n\n(let@) 10 (fun x -&gt; x + 1);;  (* apply (let@) as a function - returns 11 *)\n\nlet@ x = 10 in x + 1;;        (* use let@ binding operator - reurns 11 *)\n</code></pre> <p><code>let ( let@ ) f x = f x</code></p> <pre><code>let ( let@ ) f x = f x;;\n\nlet my_wrap fn =\n  match fn () with     (* fn () - the function fn is applied to () *)\n    | () -&gt; `Ok ()\n    | exception e -&gt; `Error (Printexc.to_string e);;\n\n(* each of the following produce the same result: \n   - not using let@\n   - applying (let@) as a function\n   - using the let@ operator  *)\n\nlet result = my_wrap (fun () -&gt; Printf.printf \"Test1 \\n%!\");;       \n\nlet result = (let@) my_wrap (fun () -&gt; Printf.printf \"Test2 \\n%!\");; \n\nlet result =\n  let@ () = my_wrap in (Printf.printf \"Test3 \\n%!\");; \n\n(* () is the fun parameter \n   if omit 'let result =' need to add ;; in front if not otherwise using ;; *)\n</code></pre>"},{"location":"operators/","title":"Operators","text":""},{"location":"operators/#operators-represent-functions","title":"Operators represent functions","text":"<p>Examples</p> <p>The <code>+</code> operator is defined to be the function <code>Int.add</code> <pre><code>(* Defining the operator '+' *)\nlet ( + ) = Int.add;;\n\n5 + 7;;\n\n(* ...is equivalent to: *)\n( + ) 5 7;;\n\n(* ...is equivalent to: *)\nInt.add 5 7;;\n</code></pre></p> <p>The <code>::</code> operator is a list constructor defined in a variant type.</p> <pre><code>type 'a list = [] | ( :: ) of 'a * 'a list;;\n\n(* As an infix operator *)\n1 :: 2 :: 3 :: [];;\n\n(* Applying :: as a variant constructor *)\n( :: ) (1,[2;3]);;\n</code></pre>"},{"location":"operators/#infix-and-prefix-operators","title":"Infix and prefix operators","text":"<ul> <li>an infix operator is placed between two arguments</li> <li>a prefix operator is placed in front of an argument</li> </ul> <p>Example</p> <p>The <code>+</code> operator is an infix operator <pre><code>x + y\n</code></pre> The <code>!</code> operator is a prefix operator <pre><code>!x\n</code></pre></p>"},{"location":"operators/#built-in-operators","title":"Built-in operators","text":"<pre><code>Operator    Description\n  =         Structural equality[1]\n &lt;&gt;         Structural inequality[1]\n  &lt;         Less than\n  &gt;         Greater than\n &lt;=         Less than or equal\n &gt;=         Greater than or equal\n ==         Physical equality (same object)[1]\n !=         Physical inequality (not same object)[1]\n &amp;&amp;         Boolean and\n  &amp;         (Deprecated) Boolean and\n ||         Boolean or\n  |         (Deprecated) Boolean or\n |&gt;         Reverse function application (x |&gt; f is the same as f x)\n @@         Function application (f @@ x is the same as f x)\n ~-         Integer negation (same as unary -)\n ~+         Described as \"unary addition\" but doesn't seem to do anything.\n  +         Integer addition\n  -         Integer subtraction\n  *         Integer multiplication\n  /         Integer division\n~-.         Float negation (same as unary -.)\n~+.         Described as \"unary addition\" but doesn't seem to do anything.\n +.         Float addition\n -.         Float subtraction\n *.         Float multiplication\n /.         Float division\n**          Float exponentiation\n ^          String concatenation\n @          List concatenation\n !          Get the value of a ref\n:=          Set the value of a ref\n^^          Format string concatenation\n</code></pre>"},{"location":"operators/#composition-operators","title":"Composition operators","text":"<p>Examples</p> <p>A function composition operator can be used to avoid using nested brackets. <pre><code>(* Three functions *)\nlet f x = x + 1\nlet g x = x + 2\nlet h x = x + 3;;\n\n(* Function composition using nested brackets *)\nh (g (f 5));;\n\n(* Using the built-in @@ infix composition operator *)\nh @@ g @@ f 5;;\n\n(* Defining an infix composition operator *)\nlet ( &amp; ) f v = f v;;\nh &amp; g &amp; f 5;;\n</code></pre></p> <p>References</p> <p>Operator cheatsheet</p>"},{"location":"tuples/","title":"Tuples","text":"<p>Access an element</p> <pre><code>let mytuple = (1,\"alpha\",['a';'b';'c'])\n\n(* Method 1 *)\nlet get_elem2 (_,el,_) = el\nget_elem2 mytuple\n\n(* Method 2 *)\n(fun (x,y,z) -&gt; y) mytuple\n\n(* Method 3 *)\nmatch mytuple with (x,y,z) -&gt; y\n</code></pre>"},{"location":"types/","title":"Type system","text":"<p>Note: stackoverflow</p> <p>From \"The C++ Programming Language\" -by Bjarne Stroustrup the creator of C++.</p> <p>A type defines a set of possible values and a set of operations (for an object).</p> <p>ref</p> <p>An attribute that identifies a piece of data and instructs a computer system on how to interpret its value is called a data type. </p> <p>Wikipedia</p> <p>There is a universe V of all values, containing simple values like integers, data structures like pairs, records and variants, and functions. This is a complete partial order, built using Scott's techniques [Scott 76], but in first approximation we can think of it as just a large set of all possible computable values. A type is a set of elements of V. Not all subsets of V are legal types: they must obey some technical properties. The subsets of V obeying such properties are called ideals. All the types found in programming languages are ideals in this sense, so we don't have to worry too much about subsets of V which are not ideals. Hence, a type is an ideal, which is a set of values. Moreover, the set of all types (ideals) over V, when ordered by set inclusion, forms a lattice. The top of this lattice is the type Top (the set of all values, i.e. V itself). The bottom of the lattice is, essentially, the empty set (actually, it is the singleton set containing the least element of V). The phrase having a type is then interpreted as membership in the appropriate set. As ideals over V may overlap, a value can have many types. The set of types of any given programming language is generally only a small subset of the set of all ideals over V. For example any subset of the integers determines an ideal (and hence a type), and so does the set of all pairs with first element equal to 3. This generality is welcome, because it allows one to accommodate many different type systems in the same framework. One has to decide exactly which ideals are to be considered interesting in the context of a particular language. A particular type system is then a collection of ideals of V, which is usually identified by giving a language of type expressions and a mapping from type expressions to ideals. The ideals in this collection are elevated to the rank of types for a particular language. For example, we can choose the integers, integer pairs and integer-to-integer functions as our type system. Different languages will have different type systems, but all these type systems can be built on top of the domain V (provided that V is rich enough to start with), using the same techniques. A monomorphic type system is one in which each value belongs to at most one type (except for the least element of V which, by definition of ideal, belongs to all types). As types are sets, a value may belong to many types. A polymorphic type system is one in which large and interesting collections of values belong to many types. There is also a grey area of mostly monomorphic and almost polymorphic systems, so the definitions are left imprecise, but the important point is that the basic model of ideals over V can explain all these degrees of polymorphism. http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf</p> <p>type  <p>(Or \"data type\") A set of values from which a variable, constant, function, or other expression may take its value. A type is a classification of data that tells the compiler or interpreter how the programmer intends to use it. For example, the process and result of adding two variables differs greatly according to whether they are integers, floating point numbers, or strings. https://foldoc.org/type</p> <p>The type of a value defines the interpretation of the memory holding it and the operations that may be performed on the value. Rust</p>"},{"location":"Appendix/extensions/","title":"Filename extensions","text":""},{"location":"Appendix/extensions/#source-code-files","title":"Source code files","text":"<code>.ml</code> OCaml implementation code <code>.mli</code> OCaml interface"},{"location":"Appendix/extensions/#compiled-code-files","title":"Compiled code files","text":"<p>References</p> <p>Real World OCaml  OCaml Manual ocamlc  OCaml Manual ocamlopt </p> <p>We\u2019ve seen how the compiler uses intermediate files to store various stages of the compilation toolchain. Here\u2019s a cheat sheet of all them in one place.   </p> <p>.ml are source files for compilation unit module implementations. .mli are source files for compilation unit module interfaces. If missing, generated from the .ml file. .cmi are compiled module interface from a corresponding .mli source file. .cmo are compiled bytecode object file of the module implementation. .cma are a library of bytecode object files packed into a single file. .o are C source files that have been compiled into native object files by the system cc. .cmt are the typed abstract syntax tree for module implementations. .cmti are the typed abstract syntax tree for module interfaces. .annot are old-style annotation file for displaying typed, superseded by cmt files. The native code compiler also generates some additional files.</p> <p>.o are compiled native object files of the module implementation. .cmx contains extra information for linking and cross-module optimization of the object file. .cmxa and .a are libraries of cmx and o units, stored in the cmxa and a files respectively. These files are always needed together. .S or .s are the assembly language output if -S is specified.</p>"},{"location":"Appendix/finding/","title":"Finding stuff","text":"<p>See introspection.md</p> <p>dune installed-??</p> <p>opam list opam search opam show</p> <p>odig</p> <p>ocp-index</p>"},{"location":"Appendix/glossary/","title":"Glossary","text":""},{"location":"Appendix/glossary/#_1","title":"<code>|</code>","text":"Pipe operator. Used to separate ???"},{"location":"Appendix/glossary/#a","title":"<code>'a</code>","text":"A type variable. A placeholder for any type. If it appears multiple times then each occurrence is the same type. A placeholder for a different type could be <code>'b</code>."},{"location":"Appendix/glossary/#application-binary-interface-abi","title":"<code>application binary interface (ABI)</code>","text":""},{"location":"Appendix/glossary/#abstract-data-type","title":"<code>abstract data type</code>","text":"See Modules and Introspection"},{"location":"Appendix/glossary/#abstract-syntax-tree-ast","title":"<code>abstract syntax tree (AST)</code>","text":""},{"location":"Appendix/glossary/#abstraction","title":"<code>abstraction</code>","text":""},{"location":"Appendix/glossary/#algebraic-data-type-adt","title":"<code>algebraic data type (ADT)</code>","text":"See Understanding types"},{"location":"Appendix/glossary/#argument","title":"<code>argument</code>","text":"See <code>parameter</code>."},{"location":"Appendix/glossary/#arity","title":"<code>arity</code>","text":""},{"location":"Appendix/glossary/#assembly-language","title":"<code>assembly language</code>","text":""},{"location":"Appendix/glossary/#association-list","title":"<code>association list</code>","text":""},{"location":"Appendix/glossary/#atomic","title":"<code>atomic</code>","text":""},{"location":"Appendix/glossary/#bnf","title":"<code>BNF</code>","text":""},{"location":"Appendix/glossary/#byte-code","title":"<code>byte code</code>","text":""},{"location":"Appendix/glossary/#concatenate","title":"<code>concatenate</code>","text":""},{"location":"Appendix/glossary/#constructor","title":"<code>constructor</code>","text":""},{"location":"Appendix/glossary/#concrete-data-type","title":"<code>concrete data type</code>","text":""},{"location":"Appendix/glossary/#continuation-passing-style-cps","title":"<code>continuation passing style (CPS)</code>","text":""},{"location":"Appendix/glossary/#currying","title":"<code>currying</code>","text":"Breaking down a function with  multiple arguments into multilple sequential functions, each with one argument   <pre><code>let add1 x y = x + y;;\n\n(* Is the same as *)\nlet add2 = fun x -&gt; fun y -&gt; x + y;;\n</code></pre>"},{"location":"Appendix/glossary/#dwarf","title":"<code>DWARF</code>","text":""},{"location":"Appendix/glossary/#elf","title":"<code>ELF</code>","text":""},{"location":"Appendix/glossary/#encapsulation","title":"<code>encapsulation</code>","text":""},{"location":"Appendix/glossary/#evaluate","title":"<code>evaluate</code>","text":""},{"location":"Appendix/glossary/#expression","title":"<code>expression</code>","text":"<p>An expression evaluates to a value. In this sense a constant is an expression<sup>1</sup> (<code>let x = 5</code>). \"The primary task of computation in a functional language is to evaluate an expression to a value\"<sup>2</sup>.   Also see Rust Chap 8 https://doc.rust-lang.org/reference/statements-and-expressions.html </p> <p>Statements are instructions that perform some action and do not return a value.</p> <p>Expressions evaluate to a resultant value. </p> <p>https://doc.rust-lang.org/book/ch03-03-how-functions-work.html</p> <p>Note: https://discuss.ocaml.org/t/what-is-the-difference-between-statements-and-expressions-in-ocaml/4525 - everything is an expression; statements return unit, like printing.</p> <p>Exampleof a statement that performs an action or has a side-effect that does not contribute to the evaluation of an expression is a print statement.</p> <p>Also good: https://stackoverflow.com/questions/50311629/statements-vs-expressions-in-haskell-ocaml-javascript</p> <p>What Rust calls a statement (eg in Rust, let x = 6 is a let statement), Ocaml calls a definition.</p> <p>The Ocaml manual seems to only use the word 'statement' in relation to 'open ...'</p>"},{"location":"Appendix/glossary/#functor","title":"<code>functor</code>","text":""},{"location":"Appendix/glossary/#garbage-collector-gc","title":"<code>garbage collector (GC)</code>","text":""},{"location":"Appendix/glossary/#generalized-algebraic-data-type-gadt","title":"<code>Generalized Algebraic Data Type (GADT)</code>","text":"See Generlized Algebraic Datatypes"},{"location":"Appendix/glossary/#heap","title":"<code>heap</code>","text":"see stack"},{"location":"Appendix/glossary/#immutable","title":"<code>immutable</code>","text":""},{"location":"Appendix/glossary/#imperative-programming","title":"<code>imperative programming</code>","text":"Imperative programming comprises executing commands in order to change memory.  Functional programming comprises evaluating expressions. <sup>3</sup>"},{"location":"Appendix/glossary/#introspection","title":"<code>introspection</code>","text":""},{"location":"Appendix/glossary/#lambda-calculus","title":"<code>lambda calculus</code>","text":"See Lambda calculus"},{"location":"Appendix/glossary/#lexer","title":"<code>lexer</code>","text":""},{"location":"Appendix/glossary/#module","title":"<code>module</code>","text":""},{"location":"Appendix/glossary/#monad","title":"<code>monad</code>","text":"See monads"},{"location":"Appendix/glossary/#mutable","title":"<code>mutable</code>","text":""},{"location":"Appendix/glossary/#native-code","title":"<code>native code</code>","text":""},{"location":"Appendix/glossary/#opacity-opaque","title":"<code>opacity</code>, <code>opaque</code>","text":""},{"location":"Appendix/glossary/#operator","title":"<code>operator</code>","text":"An operator is a symbolic representation of a function application and may be a prefix or infix operator<sup>4</sup>.   <pre><code>(* The '+' operator is an infix operator *)\nlet sum y z = y + z \n\n(* Equivalent to *)\nlet sum y z  = Int64.add y z\n\n(* Also equivalent to *)\nlet sum y z = ( + ) y z\n</code></pre>"},{"location":"Appendix/glossary/#overloading","title":"<code>overloading</code>","text":"??"},{"location":"Appendix/glossary/#parameter","title":"<code>parameter</code>","text":"<p>A function may have one or more parameters which are used in the function body.</p> <p>Concrete arguments are passed to the function when it is called. <pre><code>(* x and y are the parameters of the function named sum *)\nlet sum x y = x + y;;\n\n(* 5 and 6 are the arguments passed to sum when it is called *)\nsum 5 6;;\n</code></pre> A type may have a parameter<sup>5</sup> (see <code>parameterised type</code> below).</p> <p>A function's parameters are written to the right of the function name.</p> <p>A type's paramemters are written to the left of the type constructor.</p>"},{"location":"Appendix/glossary/#parameterised-type","title":"<code>parameterised type</code>","text":"See Parameterised type"},{"location":"Appendix/glossary/#parser","title":"<code>parser</code>","text":""},{"location":"Appendix/glossary/#pattern","title":"<code>pattern</code>","text":"<p>\"Patterns are templates that allow selecting data structures of a given shape, and binding identifiers to components of the data structure.\" Ocaml manual</p> <p>The Ocaml manual lists options for such templates, including: value name, constant, \"or\", variant, polymorphic variant, tuple, record, array, range and other patterns. </p>"},{"location":"Appendix/glossary/#polymorphism","title":"<code>polymorphism</code>","text":""},{"location":"Appendix/glossary/#primitive","title":"<code>primitive</code>","text":""},{"location":"Appendix/glossary/#stack","title":"<code>stack</code>","text":"<p>Good explanation in Rust https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</p> <p>GDB: https://sourceware.org/gdb/wiki/Internals%20All-About-Stack-Frames</p> <ul> <li>LIFO</li> <li>comprises frames </li> <li>each frame represents a function call and includes the return address</li> <li>frame includes function variables</li> <li>stack holds data that is known at compile time</li> <li>when a function returns its frame is popped off the stack</li> <li>dynamic data is stored on the heap (requiring garbage collection)</li> </ul>"},{"location":"Appendix/glossary/#statement","title":"<code>statement</code>","text":"see Rust"},{"location":"Appendix/glossary/#strict","title":"<code>strict</code>","text":""},{"location":"Appendix/glossary/#tail-recursion","title":"<code>tail recursion</code>","text":""},{"location":"Appendix/glossary/#thread","title":"<code>thread</code>","text":""},{"location":"Appendix/glossary/#turing-complete-turing-machine","title":"<code>Turing complete, Turing machine</code>","text":""},{"location":"Appendix/glossary/#type","title":"<code>type</code>","text":"<p>Data is held in memory. A compiler needs to have information about how to use what is held in memory. A value has an associated type (or data type).</p> <p>Further info: Type system</p>"},{"location":"Appendix/glossary/#value","title":"<code>value</code>","text":"An expression evaluates to a value. In this sense a constant is an expression<sup>6</sup> (<code>let x = 5</code>). A value is an expression for which there is no computation remaining to be performed<sup>7</sup>. Values include: integer numbers, floating-point numbers, characters, character strings, tuples, records, arrays, variant values, polymorphic variants, functions, objects<sup>8</sup>."},{"location":"Appendix/glossary/#variable","title":"<code>variable</code>","text":""},{"location":"Appendix/glossary/#variadic-function","title":"<code>variadic function</code>","text":"a function which can take a variable number of paramaters"},{"location":"Appendix/glossary/#when","title":"`when``","text":"<code>when</code>is a keyword used in pattern-matching guards <ol> <li> <p>The Ocaml Manual \u21a9</p> </li> <li> <p>Ocaml programming \u21a9</p> </li> <li> <p>Programming in Standard ML, chapter 2.\u00a0\u21a9</p> </li> <li> <p>The Ocaml Manual \u21a9</p> </li> <li> <p>See Constructed types The Ocaml Manual \u21a9</p> </li> <li> <p>The Ocaml Manual \u21a9</p> </li> <li> <p>Ocaml programming \u21a9</p> </li> <li> <p>The Ocaml Manual \u21a9</p> </li> </ol>"},{"location":"Appendix/introspection/","title":"Inspecting code in utop and at runtime","text":""},{"location":"Appendix/introspection/#utop","title":"utop","text":"<p>In utop</p> <p>Examples</p> <p>Display the signature of a module: <code>#show_module modulename</code>.</p> <pre><code>#show_module List;;\n\nopen Format;;\n#show_module Format;;\n</code></pre>"},{"location":"Appendix/introspection/#abstract-types","title":"Abstract types","text":"<p>See modules for examples of reducing abstraction.</p> <p>Brief explanation</p> <p>A module can hide the definition of a type.</p> <p>The signature for Mymod below does not define type t.  It is defined in the struct.</p> <p>The signature for the <code>add</code> function uses the t type.</p> <p>The following works because the <code>add</code> function is called within the struct:</p> <p><pre><code>module Mymod: sig\n  type t\n  val add: t -&gt; t -&gt; t\nend = struct\n  type t = int\n  let add x y = x + y \n  let () = Printf.printf \"Using add function: %i\\n%!\" (add 2 3)\nend\n</code></pre> The following gives an error because it expects type <code>t</code>.</p> <p>In utop</p> <pre><code>open Mymod;;\n\nlet sum = Mymod.add 3 2;;\n\n(* Error: This expression has type int but an expression was expected of type\n         Mymod.t *)\n</code></pre>"},{"location":"Appendix/syntax/","title":"Syntax summary","text":"<p>A quick reference.</p>"},{"location":"Appendix/syntax/#let","title":"let","text":"<p><code>let</code> binds a value to a name. The value bound to the name cannot be mutated. The name is an identifier and is not a variable.</p> <p>Example</p> <pre><code>let x = 42 \nlet f x = 2 * x\n</code></pre> <p>These are definitions. Definitions bind values to names. In the first case the value 42 is being bound to the name x.  In the second case, a function definition, the function <code>2 * x</code> is being bound to the name f.</p>"},{"location":"Appendix/syntax/#letin","title":"let...in","text":"<p><code>let...in</code> binds a value to a name locally. The name is not accessible globally.</p> <p>Example</p> <pre><code>let x = 2 in\nlet y = x + 3\n</code></pre>"},{"location":"Appendix/syntax/#list","title":"list","text":"<p>Examples</p> <pre><code>let mylist1 = [1;2;3]\nlet mylist2 = 0::mylist1\nmylist2 @ [4]   (* returns [0; 1; 2; 3; 4] *)\n</code></pre>"},{"location":"Appendix/syntax/#tuple","title":"tuple","text":"<p>Examples</p> <pre><code>let mytuple = (1,\"alpha\",mylist1)\n</code></pre>"},{"location":"Appendix/syntax/#record","title":"record","text":"<p>Examples</p> <pre><code>type myrecord = {first:string; second:int}\nlet record1 = {first = \"alpha\"; second = 2}\nrecord1.first   (* returns \"alpha\" *)\n\nlet record2 = {record1 with second = 3}\nrecord2   (* returns {first = \"alpha\"; second = 3} *)   \n</code></pre>"},{"location":"Appendix/syntax/#array","title":"array","text":"<p>Examples</p> <pre><code>let myarray = [| 1; 2; 3; 4; 5 |]\nmyarray.(2)    (* returns 3 *)\n</code></pre>"},{"location":"Arrays/array_create/","title":"Create and access an array","text":"<p>Quotes</p> <p>Arrays are finite, variable-sized sequences of values of the same type. Reference</p> <p>Arrays are fixed-length mutable sequences with constant-time access and update. So they are similar in various ways to refs, lists, and tuples. Like refs, they are mutable. Like lists, they are (finite) sequences. Like tuples, their length is fixed in advance and cannot be resized. Reference</p> <p>Create an array</p> <p><pre><code>let numbers = [|1;2;3;4;5|]\n</code></pre> <pre><code>let arr = Array.make 5 0  (* returns [| 0; 0; 0; 0; 0|] *)\n</code></pre></p> <p>Get an element in an array</p> <p><pre><code>let el = numbers.(2)          (* returns 3 *)\n</code></pre> <pre><code>let el = Array.get numbers 2  (* returns 3 *)\n</code></pre></p> <p>Set an element in an array</p> <p><pre><code>numbers.(2) &lt;- 9              (* changes element 2 in place *)\n</code></pre> <pre><code>Array.set numbers 2 9\n</code></pre></p>"},{"location":"Controls/ifelse/","title":"if...else","text":""},{"location":"Controls/loops/","title":"Loops","text":""},{"location":"Controls/overview/","title":"Control structures","text":"<p>References</p> <p>Ocaml manual</p>"},{"location":"Controls/sequences/","title":"Sequences","text":"<p>caml.inria.fr/pub/docs  https://ocaml.org/manual/5.3/expr.html#ss%3Aexpr-control</p>"},{"location":"Data/hash_tables/","title":"Hash tables","text":""},{"location":"Data/sequences/","title":"Sequences","text":""},{"location":"Functions/functions/","title":"Functions","text":""},{"location":"Functions/functions/#anonymous-functions","title":"Anonymous functions","text":"<p>Sometimes referred to as lambda expressions.</p> <pre><code>(* Anonymous function with 1 parameter, x *)\nfun x -&gt; 2 * x;;\n\n(* Anonymous function with 2 parameters, x &amp; y *)\nfun x y -&gt; x + y;;\n\n(* Can be expressed as two functions with single parameters *)\nfun x -&gt; (fun y -&gt; x + y);;\n\n(* Applying an anonymous function *)\n(fun x -&gt; 2 * x) 5;;        (* Returns 10 *)\n(fun x y -&gt; x + y) 6 7;;    (* Returns 13 *)\n\n(* Anonymous function and pattern-matching *)\nfun x y -&gt; match x &gt; y with\n| true -&gt; (string_of_int x) ^ \" is greater than \" ^ (string_of_int y)\n| false -&gt; (string_of_int x) ^ \" is less than or equal to \" ^ (string_of_int y)\n</code></pre>"},{"location":"Functions/functions/#named-functions","title":"Named functions","text":"<pre><code>(* Named function with 1 parameter *)\nlet double = fun x -&gt; 2 * x;;\n\n(* Common syntax *)\nlet double x = 2 * x;;\n\n(* Named function with 2 parameters *)\nlet add = fun x y -&gt; x + y;;\n\n(* Common syntax *)\nlet add x y = x + y;;\n\n(* Applying a named function *)\ndouble 5;;    (* Returns 10 *)\nadd 6 7;;     (* Returns 13 *)\n\n(* Named function and pattern-matching *)\nlet compare = fun x y -&gt; match x &gt; y with\n  | true -&gt; (string_of_int x) ^ \" is greater than \" ^ (string_of_int y)\n  | false -&gt; (string_of_int x) ^ \" is less than or equal to \" ^ (string_of_int y)\n\n(* Common syntax *)\nlet compare x y = match x &gt; y with\n| true -&gt; (string_of_int x) ^ \" is greater than \" ^ (string_of_int y)\n| false -&gt; (string_of_int x) ^ \" is less than or equal to \" ^ (string_of_int y)\n</code></pre>"},{"location":"Functions/functions/#function-keyword","title":"<code>function</code> keyword","text":"<ul> <li>automatically uses pattern matching</li> <li>only takes one parameter</li> </ul> <pre><code>(* Function with a parameter *)\n(* Is a special case of pattern matching - there is only one case and it returns an expression *)\nfunction x -&gt; 2 * x;;\n\n(* Applying function *)\n(function x -&gt; 2 * x) 5;;\n\n(* Pattern matching *)\n(* One pattern tested *)\n(function | x -&gt; 2 * x) 5;;\n(function x -&gt; 2 * x) 5 ;; (* Same as above *)\n\n(* Two patterns tested - whether the parameter is 0 or some other integer *)\n(function | 0 -&gt; \"this is zero\" | _ -&gt; \"this is not zero\") 5;;\n(function 0 -&gt; \"this is zero\" | _ -&gt; \"this is not zero\") 5);; (* Same as above *)\n\n(* Function is bound to a name *)\nlet myfunction = function \n  | 0 -&gt; \"this is zero\" \n  | _ -&gt; \"this is not zero\";;\n\n(* Named function is applied to a parameter *)\nmyfunction 5;;\n</code></pre>"},{"location":"Getting%20started/manual/","title":"The Ocaml manual notation","text":"<p>The official Ocaml manual uses BNF-like notation.</p>"},{"location":"Getting%20started/manual/#what-is-bnf","title":"What is BNF?","text":"<p>BNF (Backus Naur Form) notation</p> <code>terminal symbol</code> <ul> <li>cannot be replaced</li> <li>enclosed in quotes <code>\"...\"</code></li> </ul> <code>non-terminal symbol</code> <ul> <li>can be replaced</li> <li>enclosed in angle brackets <code>&lt;...&gt;</code></li> </ul> <code>&lt;symbol&gt; ::= __expression__</code> <p>Meaning:</p> <ul> <li>the non-terminal symbol on the left is replaced by the expression</li> <li>is referred to as a \"rule\"</li> </ul> <p><code>|</code>\u2003\u2003\u2003\u2003\u2002indicates a choice</p> <p><code>+</code>\u2003\u2003\u2003\u2003\u2002one or more of the previous</p> <p><code>*</code>\u2003\u2003\u2003\u2003\u2002zero or more of the previous</p> <p><code>?</code>\u2003\u2003\u2003\u2003\u2002zero or one occurances of the previous</p> <p><code>[...]</code>\u2003\u2003optional</p> <p><code>{...}</code>\u2003\u2003repetition</p> <p><code>(...)</code>\u2003\u2003grouping</p> <p><code>(*...*)</code>\u2002\u2009comment</p> <p>Wikipedia BNF playground</p>"},{"location":"Getting%20started/manual/#ocaml-manual-bnf-like-notation","title":"Ocaml manual BNF-like notation","text":"<p>From the Ocaml manual</p> <p>Terminal symbols are set in typewriter font (<code>like this</code>). Non-terminal symbols are set in italic font (like that). Square brackets <code>[\u2026]</code> denote optional components. Curly brackets <code>{\u2026}</code> denotes zero, one or several repetitions of the enclosed components. Curly brackets with a trailing plus sign <code>{\u2026}+</code> denote one or several repetitions of the enclosed components. Parentheses <code>(\u2026)</code> denote grouping.</p> <p>Examples</p> <p>ident ::= (letter | _ ){letter | 0\u20269 | _ | '}</p> <p>letter    ::= A\u2026Z | a\u2026z</p> <p>Meaning</p> <p>An identifier (ident) commences with a letter or underscore. That is followed by zero or more: letters, numerals, underscores or '.</p> <p>A letter is any uppercase or lowercase alphabetical literal.</p>"},{"location":"Getting%20started/opam/","title":"opam","text":"<p>opam is Ocaml's package manager.</p>"},{"location":"Getting%20started/opam/#opam-help","title":"opam help","text":"<p>In a terminal: <pre><code>opam --help\nopam &lt;subcommand&gt; --help\n</code></pre></p>"},{"location":"Getting%20started/opam/#list-packages","title":"List packages","text":"<p>Example</p> <p>In a terminal: <pre><code># List installed packages\nopam list\n\n# List all available packages\nopam list -a\n</code></pre></p>"},{"location":"Getting%20started/opam/#search-for-a-package","title":"Search for a package","text":"<p>Example</p> <p>In a terminal:</p> <pre><code># Search for all packages mentioning 'lwt'\nopam list --search lwt\nopam search lwt\n</code></pre>"},{"location":"Getting%20started/opam/#show-information-about-a-package","title":"Show information about a package","text":"<p>Example</p> <p>In a terminal: <pre><code># Show information about the lwt package\nopam show lwt\n\n# Show the files installed by lwt\nopam show --list-files lwt\n</code></pre></p>"},{"location":"Getting%20started/opam/#switches","title":"Switches","text":"<p>Packages are installed in switches. These are independent installations of the ocaml compiler  and the packages you have installed in that switch. If you want to try a new compiler version but don't want to upset dependencies of your current set of installed packages then you can create a new switch based on the new compiler.</p> <p>Example</p> <p>In a terminal:</p> <pre><code># Help for switches\nopam switch --help\n\n# Show installed switches\nopam switch list\n# or just:\nopam switch\n\n# Show available ocaml compiler versions\nopam list ocaml\n\n# Create a new switch using ocaml compiler version \"4.14.1\"\nopam switch create 4.14.1   \n# or, giving it a label:\nopam switch create \"myswitch\" 4.14.1\n\n# Set a switch, from the available switches, for the current environment\nopam switch set 4.14.1\n# then do:\neval $(opam env)\n</code></pre>"},{"location":"Getting%20started/styleguide/","title":"Syntax and style guide","text":"<p>References</p> <p>Jane Street style guide OCaml Best Practices for Developers</p>"},{"location":"Getting%20started/styleguide/#names-upper-lower-case","title":"Names - upper / lower case","text":"<p>Examples</p> <pre><code>(* Identifiers: snake_case not camelCase *)\nlet my_identifier = \"mystring\";;\n\n(* Variant names: Upper case *)\ntype myvariant = | First of int | Second of int\n\n(* Module names: Upper case*)\nmodule Mymodule = struct\n  ...\nend\n</code></pre>"},{"location":"Getting%20started/styleguide/#-semicolon","title":"; - semicolon","text":"<p>A semicolon separates statements.</p> <p>Otherwise lines in Ocaml code do not end in a semi-colon.</p> <p>Example</p> <pre><code>print_int 5;\nprint_string \"things\";\nprint_endline \"here\"\n</code></pre>"},{"location":"Getting%20started/styleguide/#-double-semi-colon","title":";; - double semi-colon","text":"<p>Used in utop to tell utop to evaluate. Not needed at end of each line. A phrase needs to be evaluated if its result is used in successive phrases.</p> <p>Example</p> <p>In utop: <pre><code>(* In the code below the module Printf is opened so \nwe can use printf instead of having to write Printf.printf *)\n\n(* The only place that needs a ;; is at the end to tell utop to evaluate *)\nopen Printf\nlet myconst = 5\nlet () = printf \"myconst is %i \\n%!\" myconst\nlet () = print_endline \"the end\";;\n\n(* Sometimes if utop gives a syntax error message it may \n   be due to a missed ;; - utop may need to evaluate \n   preceding expressions before proceeding further *)\n</code></pre></p>"},{"location":"Getting%20started/utop/","title":"Universal toplevel for OCaml (utop)","text":"<p>References</p> <p>A blog post on opam.ocaml.org   Github utop README Ocaml Programming  Ocaml manual: Top level</p>"},{"location":"Getting%20started/utop/#getting-started-with-utop","title":"Getting started with utop","text":""},{"location":"Getting%20started/utop/#install","title":"Install","text":"<p>In a terminal: <pre><code>opam install utop\n</code></pre></p>"},{"location":"Getting%20started/utop/#help","title":"Help","text":"<p>In a terminal: <pre><code>man utop\nutop --help\n</code></pre> In utop itself: <pre><code>#help\n</code></pre></p>"},{"location":"Getting%20started/utop/#start-utop","title":"Start utop","text":"<p>In a terminal: <pre><code>utop\n</code></pre></p>"},{"location":"Getting%20started/utop/#using-utop","title":"Using utop","text":""},{"location":"Getting%20started/utop/#ending-phrases","title":"Ending phrases","text":"<p>Place a double semicolon ;; at the end of a phrase to tell utop to evaluate and print the result of the given phrase. It will not evaluate the phrase otherwise.</p>"},{"location":"Getting%20started/utop/#completion-bar","title":"Completion bar","text":"<p>The completion bar at the bottom shows possible completions as you type.</p> <p>Note</p> <p><pre><code>M-left, M-right:  to move along the completion bar      \nM-down:           to select a word\n</code></pre> (The M key is usually the alt key)</p>"},{"location":"Getting%20started/utop/#directives","title":"Directives","text":"<p>Directives are instructions to utop and not part of the code. Directives begin with <code>#</code>.</p> <p>Example</p> <p>In utop: <pre><code>(* help *)\n#help;;\n\n(* help using utop *)\n#utop_help;;\n\n(* key bindings *)\n#utop_bindings;;\n\n(* require a package *)\n#require \"package name\";;\n</code></pre></p>"},{"location":"Getting%20started/utop/#packages-libraries-and-modules","title":"Packages, libraries and modules","text":""},{"location":"Getting%20started/utop/#use-opam-to-find-packages-list-installed-packages-or-show-a-package","title":"Use opam to find packages, list installed packages or show a package.","text":"<p>Using opam</p> <p>We know we have the package <code>lwt</code> installed - what should utop <code>#require</code> and what are the module names to <code>open</code>?</p> <p>In a terminal: <pre><code>opam show --list-files lwt\n\n...\n../.opam/4.14.1/lib/lwt/unix/lwt_gc.ml\n../.opam/4.14.1/lib/lwt/unix/lwt_gc.mli\n../.opam/4.14.1/lib/lwt/unix/lwt_io.cmi\n../.opam/4.14.1/lib/lwt/unix/lwt_io.cmt\n../.opam/4.14.1/lib/lwt/unix/lwt_io.cmti\n../.opam/4.14.1/lib/lwt/unix/lwt_io.cmx\n../.opam/4.14.1/lib/lwt/unix/lwt_io.ml\n../.opam/4.14.1/lib/lwt/unix/lwt_io.mli\n../.opam/4.14.1/lib/lwt/unix/lwt_main.cmi\n../.opam/4.14.1/lib/lwt/unix/lwt_main.cmt\n../.opam/4.14.1/lib/lwt/unix/lwt_main.cmti\n...\n</code></pre> As usual, module names are file names capitalised.</p> <p>This shows there is a module <code>Lwt_io</code> which can be accessed in utop by requiring the package \"lwt.unix\"</p> <p>To show the signatures of all the types and functions provided by the Lwt_io module, in utop: <pre><code>#require \"lwt.unix\";;\n#show Lwt_io;;\n</code></pre> To open the module <code>Lwt_io</code> in utop:</p> <pre><code>#require \"lwt.unix\";;\nopen Lwt_io;;\n</code></pre>"},{"location":"Getting%20started/utop/#use-dune-to-show-installed-libraries","title":"Use dune to show installed libraries","text":"<p>Using dune</p> <pre><code>dune installed-libraries\n\n...\nlwt                                   (version: 5.9.1)\nlwt.unix                              (version: 5.9.1)\nlwt_react                             (version: 1.2.0)\n...\n</code></pre>"},{"location":"Internals/stackheap/","title":"Processes, threads, frames, stack, heap","text":""},{"location":"Internals/stackheap/#processes-and-threads","title":"Processes and threads","text":"<p>A process is an instance of an executing program.</p> <p>A process will have one or more threads.</p> <p>Each process has its own memory space. Communication between processes is termed Inter Process Communication (IPC).</p> <p>Each thread has access to its own stack and registers.</p> <p>In Linux, processes and threads are both tasks and what distinguishes them are their \"context of execution\" (COE).</p> <p>Quotes</p> <p>A process is an operating system abstraction that groups together multiple resources:</p> <ul> <li>An address space</li> <li>One or more threads</li> <li>Opened files</li> <li>Sockets</li> <li>Semaphores</li> <li>Shared memory regions</li> <li>Timers</li> <li>Signal handlers</li> <li>Many other resources and status information</li> </ul> <p>Linux kernel labs</p> <p>A thread is the entity within a process that can be scheduled for execution. All threads of a process share its virtual address space and system resources. In addition, each thread maintains exception handlers, a scheduling priority, thread local storage, a unique thread identifier, and a set of structures the system will use to save the thread context until it is scheduled. The thread context includes the thread's set of machine registers, the kernel stack, a thread environment block, and a user stack in the address space of the thread's process. Threads can also have their own security context, which can be used for impersonating clients.</p> <p>Microsoft</p> <p>In some operating systems, such as GNU/Linux and Solaris, a single program may have more than one thread of execution. The precise semantics of threads differ from one operating system to another, but in general the threads of a single program are akin to multiple processes\u2014except that they share one address space (that is, they can all examine and modify the same variables). On the other hand, each thread has its own registers and execution stack, and perhaps private memory.</p> <p>GDB</p>"},{"location":"Internals/stackheap/#references","title":"References","text":"<p>Linus Torvalds</p> <p>Linux Kernel Labs</p> <p>Site24x7</p> <p>Applied programming</p> <p>Procedure Call Standard for the Arm\u00ae 64-bit Architecture (AArch64)</p>"},{"location":"Libraries/janest/","title":"Jane Street","text":""},{"location":"Libraries/lwt/","title":"Lwt","text":"<p>This library provides concurrency in Ocaml. The key concept is a promise.</p> <p>Description - from the lwt package:</p> <p>A promise is a value that may become determined in the future.              Lwt provides typed, composable promises. Promises that are resolved by I/O are              resolved by Lwt in parallel.              Meanwhile, OCaml code, including code creating and waiting on promises, runs in              a single thread by default. This reduces the need for locks or other              synchronization primitives. Code can be run in parallel on an opt-in basis.</p>"},{"location":"Libraries/lwt/#utop","title":"utop","text":"<p>If using utop to run examples, tell it to use the lwt package.</p> <p>Example</p> <pre><code>#require \"lwt\";;\n</code></pre>"},{"location":"Libraries/lwt/#promise","title":"Promise","text":"<ul> <li>a value that is permitted to mutate once</li> <li>does not block program flow</li> <li>like an empty box waiting to be filled</li> <li>once it is created it is pending</li> <li>when it is fulfilled, or rejected, it is resolved </li> <li>for example, a function waiting for user input from the terminal</li> </ul> <ul> <li>Promises of type <code>'a Lwt.t</code> are placeholders for values of type <code>'a</code>.</li> <li><code>Lwt.bind</code> attaches callbacks to promises. When a promise gets a value, its callbacks are called.</li> <li>Separate resolvers of type <code>'a Lwt.u</code> are used to write values into promises, through <code>Lwt.wakeup_later</code>.</li> <li>Promises and resolvers are created in pairs using <code>Lwt.wait</code>. Lwt I/O functions call <code>Lwt.wait</code> internally, but return only the promise.</li> <li><code>Lwt_main.run</code> is used to wait on one \u201ctop-level\u201d promise. When that promise gets a value, the program terminates.</li> </ul>"},{"location":"Libraries/lwt/#state","title":"State","text":"<p>A promise is a memory cell that is always in one of three states:</p> <ul> <li>fulfilled, and containing one value of type 'a,</li> <li>rejected, and containing one exception, or</li> <li>pending, in which case it may become fulfilled or rejected later.</li> </ul>"},{"location":"Libraries/lwt/#create-a-promise","title":"Create a promise","text":""},{"location":"Libraries/lwt/#fulfilled-with-the-given-value","title":"Fulfilled with the given value.","text":"<p><code>Lwt.return : 'a -&gt; 'a Lwt.t</code></p>"},{"location":"Libraries/lwt/#rejected-with-the-given-exception","title":"Rejected with the given exception.","text":"<p><code>Lwt.fail : exn -&gt; 'a Lwt.t</code></p>"},{"location":"Libraries/lwt/#pending-with-resolver","title":"Pending with resolver","text":"<p>Create a pending promise, and return it, paired with a resolver (of type 'a Lwt.u), which must be used to resolve (fulfill or reject) the promise.</p> <p><code>Lwt.wait : unit -&gt; 'a Lwt.t * 'a Lwt.u</code></p>"},{"location":"Libraries/lwt/#resolve-a-pending-promise","title":"Resolve a pending promise","text":""},{"location":"Libraries/lwt/#fulfill-the-promise-with-a-value","title":"Fulfill the promise with a value","text":"<p><code>Lwt.wakeup : 'a Lwt.u -&gt; 'a -&gt; unit</code> </p>"},{"location":"Libraries/lwt/#reject-the-promise-with-an-exception","title":"Reject the promise with an exception","text":"<p><code>Lwt.wakeup_exn : 'a Lwt.u -&gt; exn -&gt; unit</code> </p> <p>Example</p> <pre><code>let (p : int Lwt.t), r = Lwt.wait ();;\nLwt.wakeup_later r 42;;\n</code></pre>"},{"location":"Libraries/lwt/#bind-a-promise-to-a-function-lwtbind","title":"Bind a promise to a function - <code>Lwt.bind</code>","text":"<p><code>bind p f</code> creates a promise which waits for <code>p</code> to become become fulfilled, then passes the resulting value to <code>f</code>. If <code>p</code> is a pending promise, then <code>bind p f</code> will be a pending promise too, until <code>p</code> is resolved. If <code>p</code> is rejected, then the resulting promise will be rejected with the same exception. </p> <p><code>f</code> is a callback function</p> <p>Example</p> <pre><code>Lwt.bind\n  (Lwt_io.read_line Lwt_io.stdin)\n  (fun str -&gt; Lwt_io.printlf \"You typed %S\" str)\n</code></pre>"},{"location":"Libraries/lwt/#running-an-lwt-program-lwt_mainrun","title":"Running an Lwt program - <code>Lwt_main.run</code>","text":"<p>This function waits for the given promise to resolve and returns its result. In fact it does more than that; it also runs the scheduler which is responsible for making asynchronous computations progress when events are received from the outside world.</p> <p>Example</p> <p>In utop: <code>#require \"lwt.unix\";;</code> <pre><code>let () = Lwt_main.run (Lwt_io.printl \"Hello, world!\");;\n</code></pre></p>"},{"location":"Libraries/lwt/#syntactic-sugar-for-bind-letlwt-and-let","title":"Syntactic sugar for bind - <code>let%lwt</code> and <code>let*</code>","text":"<p>Examples</p> <p>In utop: <code>#require \"lwt_ppx\";;</code></p> <pre><code>(* Without syntactic sugar *)\nlet () =\n  Lwt_main.run begin\n    Lwt.bind Lwt_io.(read_line stdin) (fun line -&gt;\n      Lwt.bind (Lwt_unix.sleep 1.) (fun () -&gt;\n        Lwt_io.printf \"One second ago, you entered %s\\n\" line))\n  end;;\n\n(* Using let%lwt - requires lwt_ppx *)\nlet () = \n  Lwt_main.run begin\n    let%lwt line = Lwt_io.(read_line stdin) in              (* promise *)\n    let%lwt () = Lwt_unix.sleep 1. in                       (* promise *)\n    Lwt_io.printf \"One second ago, you entered %s\\n\" line   (* callback *)\n  end;;\n\n(* Using let* *)\nlet ( let* ) = Lwt.bind;;\nlet () = \n  Lwt_main.run begin\n    let* line = Lwt_io.(read_line stdin) in                 (* promise *)\n    let* () = Lwt_unix.sleep 1. in                          (* promise *)\n    Lwt_io.printf \"One second ago, you entered %s\\n\" line   (* callback *)\n  end;;      \n</code></pre>"},{"location":"Libraries/stdlib/","title":"The Standard Library","text":""},{"location":"Lists/list_create/","title":"Lists","text":"<p>Create a list</p> <pre><code>let myemptylist = []\nlet mylist = [1;2;3;4]\nlet mylist = 1::2::3::4::[]\nlet mylist = List.cons 1 myemptylist  (* returns [1] *)\nlet mylist = List.cons 2 mylist       (* returns [2:1] *)\nlet mylist = List.init 5 (fun x -&gt; x) (* returns [0;1;2;3;4] *)\n</code></pre> <p>Get an element in a list</p> <pre><code>let mylist = [1;2;3;4]\nlet hd = List.hd mylist               (* returns 1 *)\nlet seconditem = List.nth mylist 1    (* returns 2 *)\n</code></pre> <p>Set an element in a list</p> <p>Elements in lists are not mutable. But a list itself can have elements added or removed.</p>"},{"location":"Lists/list_ops/","title":"Operations on lists","text":"<p>List.fold_left</p> <pre><code>(* List.fold_left: takes an operator, an accumulator, a list \n   and returns the accumulator.  *)\n\n(* In the example below: \n   2 + 3 = 5\n   5 + 1 = 6\n   6 + 5 = 11 \n   Returns 11    *)\n\nList.fold_left (+) 2 [3;1;5]\n\n(* Same as: *)\nList.fold_left (fun x y -&gt; x + y) 2 [3;1;5]\n</code></pre>"},{"location":"Modules/applicative/","title":"Applicative functors","text":""},{"location":"Modules/applicative/#a-use-case-for-an-applicative-functor","title":"A use case for an applicative functor","text":"<p>It is easy enough to add two numbers: <pre><code>let myadd x y = x + y\n</code></pre> If the numbers are each wrapped into an Option type then addition is more difficult. <pre><code>myadd (Some 3) (Some 4);;\n</code></pre> utop says: <pre><code>Error: This expression has type 'a option\n       but an expression was expected of type int\n</code></pre> An applicative functor to the rescue ....</p> <p>ChatGPT</p> <p>Prompt: Explain applicative functor in Ocaml</p> <p>ChatGPT:</p> <p>An applicative functor is a structure that allows you to apply functions wrapped in a context to values also wrapped in a context.  etc ....</p>"},{"location":"Modules/applicative/#applicative-functor-signature","title":"Applicative functor signature","text":"<p>An applicative has the signature:</p> <pre><code>module type FUNCTOR = sig\n  type 'a t\n  val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\nend;;\n\nmodule type APPLICATIVE = sig\n  include FUNCTOR\n  val pure : 'a -&gt; 'a t\n  val apply : ('a -&gt; 'b) t -&gt; 'a t -&gt; 'b t\nend;;\n</code></pre>"},{"location":"Modules/applicative/#applicative-functor-examples","title":"Applicative functor examples","text":"<p>OptionApplicative</p>"},{"location":"Modules/applicative/#first-define-a-module-optionapplicative","title":"First define a module: OptionApplicative","text":"<pre><code>module type FUNCTOR = sig\n  type 'a t\n  val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t\nend;;\n\nmodule type APPLICATIVE = sig\n  include FUNCTOR\n  val pure : 'a -&gt; 'a t\n  val apply : ('a -&gt; 'b) t -&gt; 'a t -&gt; 'b t\nend;;\n\nmodule OptionApplicative : APPLICATIVE with type 'a t = 'a option = struct\n  type 'a t = 'a option\n\n  let pure x = Some x\n\n  let apply f_opt x_opt =\n    match f_opt, x_opt with\n    | Some f, Some x -&gt; Some (f x)\n    | _ -&gt; None\n\n  let map f x_opt =\n    match x_opt with\n    | Some x -&gt; Some (f x)\n    | None -&gt; None\nend;;\n</code></pre>"},{"location":"Modules/applicative/#examine-optionapplicative","title":"Examine OptionApplicative","text":"<p>Copy the definition above into utop then open it in utop. <pre><code>open OptionApplicative;;\n</code></pre></p>"},{"location":"Modules/applicative/#the-pure-function","title":"The <code>pure</code> function","text":"<p>The <code>pure</code> function lifts an ordinary type (in this case <code>int</code>) into the OptionApplicative type (<code>int t</code> which is equal to <code>int option</code>): <pre><code>let z = pure 6;;\nval z : int t = Some 6\n</code></pre> <code>z</code> has type <code>int t</code> and the value of <code>z</code> is <code>Some 6</code></p>"},{"location":"Modules/applicative/#the-apply-function","title":"The <code>apply</code> function","text":"<p>This function is defined as: <pre><code>let apply f_opt x_opt =\n  match f_opt, x_opt with\n  | Some f, Some x -&gt; Some (f x)\n  | _ -&gt; None\n</code></pre> Pattern-matching shows that in the case that <code>f_opt</code> matches the pattern <code>Some f</code> and <code>x_opt</code> matches the pattern <code>Some x</code>  then the <code>apply</code> function will return <code>Some (f x)</code>. <code>(f x)</code> indicates <code>f</code> is a function that is applied to <code>x</code>.</p> <p>The signature of the <code>apply</code> function is: <pre><code>#show apply;;\nval apply : ('a -&gt; 'b) t -&gt; 'a t -&gt; 'b t\n</code></pre> This means the first parameter of <code>apply</code> has type <code>('a -&gt; 'b) t</code> which is a function of type <code>('a -&gt; b')</code> which has been converted to type <code>('a -&gt; b') t</code>. This function <code>('a -&gt; b')</code> takes one parameter of type <code>'a</code> and returns a value of type <code>'b</code>. A function of type <code>('a -&gt; 'b)</code> can be converted to a function of type <code>('a -&gt; 'b) t</code> using the <code>pure</code> function.</p>"},{"location":"Modules/applicative/#incrementing-an-integer-parameter-of-option-type","title":"Incrementing an integer parameter of option type","text":"<p>The function <code>fun x -&gt; x + 1</code> takes an integer parameter and returns a value equal to the parameter incremented by 1.</p> <pre><code>apply (pure (fun x -&gt; x + 1)) (Some 3);;\n- : int t = Some 7\n</code></pre>"},{"location":"Modules/applicative/#adding-two-integers-of-option-types","title":"Adding two integers of option types","text":"<p>A function that adds two integers takes two parameters:</p> <pre><code>let myadd x y = x + y\n</code></pre> <p>This can be split into two functions, each taking one parameter. It can be partially applied.</p> <p><pre><code>let myadd = (fun x -&gt; (fun y -&gt; x + y));;\n\nlet z = myadd 5 6;;          (* apply myadd to two parameters  - returns the sum *)\nval z : int = 11\n\nlet z = myadd 5;;            (* apply myadd to only one parameter - returns a function taking one parameter *)\nval z : int -&gt; int = &lt;fun&gt;\n\nz 6;;\n- : int = 11                 (* apply z to one parameter *)\n</code></pre> In a similar fashion <code>apply</code> can be applied to a function and two parameters:</p> <p><pre><code>let myoptadd = apply (apply (pure (fun x -&gt; (fun y -&gt; x + y))) (Some 3)) (Some 4);;\nval myoptadd : int t = Some 7\n</code></pre> An alternative way to write this:</p> <pre><code>let myoptadd1 = (pure (fun x -&gt; (fun y -&gt; x + y)))\nlet myoptadd = apply (apply myoptadd1 (Some 3)) (Some 4);;\n</code></pre>"},{"location":"Modules/applicative/#the-infix-operator","title":"The infix operator <code>&lt;*&gt;</code>","text":"<p><pre><code>let ( &lt;*&gt; ) = apply\n</code></pre> Instead of writing <code>apply fx x</code> we write <code>fx &lt;*&gt; x</code>.</p> <p>Using the infix operator <code>+</code> as a function <code>( + )</code>, these are equivalent:</p> <p><pre><code>let z1 = apply (pure (+)) (Some 3);;\nlet z2 = (pure (+)) &lt;*&gt; (Some 3);;\n</code></pre> And these are equivalent: <pre><code>let sum1 = apply y (Some 4);;\nlet sum2 = y &lt;*&gt; (Some 4);;\n</code></pre></p>"},{"location":"Modules/applicative/#references","title":"References","text":"<p>References</p> <p>Applicative programming with effects More type classes in Ocaml</p>"},{"location":"Modules/applicative/#grok","title":"Grok","text":"<p>Grok</p> <p>In OCaml, an applicative functor is a concept from functional programming that generalizes the idea of a functor (something that can be mapped over, like a list or option) by adding the ability to apply functions wrapped in the functor context to values also wrapped in that same context. It\u2019s a powerful abstraction that sits between functors and monads in terms of expressiveness.</p> <p>Let me break it down step-by-step and provide an explanation with OCaml examples.</p>"},{"location":"Modules/applicative/#definition","title":"Definition","text":"<p>An applicative functor is a type constructor (like <code>'a option</code> or <code>'a list</code>) equipped with two key operations:</p> <ol> <li> <p><code>pure</code>: A way to lift a value into the functor context.</p> <ul> <li>Signature: <code>'a -&gt; 'f 'a</code></li> <li>Example: For <code>option</code>, this would turn a value <code>x</code> into <code>Some x</code>.</li> </ul> </li> <li> <p><code>apply</code> (or <code>&lt;*&gt;)</code>: A way to apply a function wrapped in the functor to a value wrapped in the same functor.</p> <ul> <li>Signature: <code>'f ('a -&gt; 'b) -&gt; 'f 'a -&gt; 'f 'b</code></li> <li>Example: Apply <code>Some (fun x -&gt; x + 1)</code> to <code>Some 5</code> to get <code>Some 6</code>.</li> </ul> </li> </ol> <p>In OCaml, we typically define these operations in a module that represents the applicative functor.</p>"},{"location":"Modules/applicative/#example-option-as-an-applicative-functor","title":"Example: Option as an Applicative Functor","text":"<p>The <code>option</code> type is a classic example of an applicative functor. Here's how we might define it:</p> <pre><code>module OptionApplicative = struct\n  type 'a t = 'a option\n\n  (* Lift a value into the option context *)\n  let pure x = Some x\n\n  (* Apply a wrapped function to a wrapped value *)\n  let apply fo xo =\n    match fo, xo with\n    | Some f, Some x -&gt; Some (f x)\n    | _ -&gt; None\nend\n</code></pre> <ul> <li><code>pure</code>: Takes any value <code>x</code> and wraps it in <code>Some</code>, placing it in the <code>option</code> context.</li> <li><code>apply</code>: Takes a function wrapped in an <code>option</code> (e.g., <code>Some (fun x -&gt; x + 1)</code>) and a value wrapped in an <code>option</code> (e.g., <code>Some 5</code>), and applies the function to the value if both are <code>Some</code>. If either is <code>None</code>, the result is <code>None</code>.</li> </ul>"},{"location":"Modules/applicative/#usage","title":"Usage","text":"<pre><code>let f = OptionApplicative.pure (fun x -&gt; x + 1)  (* Some (fun x -&gt; x + 1) *)\nlet x = OptionApplicative.pure 5                (* Some 5 *)\nlet result = OptionApplicative.apply f x        (* Some 6 *)\n\nlet f2 = OptionApplicative.pure (+)\nlet result2 = OptionApplicative.apply (OptionApplicative.apply f2 (Some 3)) (Some 4)  (* Some 7 *)\n</code></pre> <p>In the second example, we use <code>apply</code> twice to handle a binary function (<code>+</code>), applying it to <code>Some 3</code> and <code>Some 4</code> to get <code>Some 7</code>.</p>"},{"location":"Modules/applicative/#properties-of-applicative-functors","title":"Properties of Applicative Functors","text":"<p>Applicative functors must satisfy certain laws (though we don\u2019t enforce them in code):</p> <ol> <li>Identity: <code>apply (pure id) x = x</code><ul> <li>Applying the identity function wrapped in <code>pure</code> does nothing.</li> </ul> </li> <li>Composition: <code>apply (apply (pure (fun x y -&gt; x (y z))) f) g x = apply f (apply g x)</code><ul> <li>Function composition works as expected.</li> </ul> </li> <li>Homomorphism: <code>apply (pure f) (pure x) = pure (f x)</code><ul> <li>Applying a pure function to a pure value is the same as applying the function and then lifting the result.</li> </ul> </li> <li>Interchange: <code>apply f (pure x) = apply (pure (fun g -&gt; g x)) f</code><ul> <li>The order of lifting and applying can be swapped in a specific way.</li> </ul> </li> </ol> <p>These laws ensure that the applicative functor behaves predictably.</p>"},{"location":"Modules/applicative/#another-example-list-as-an-applicative-functor","title":"Another Example: List as an Applicative Functor","text":"<p>The <code>list</code> type can also be an applicative functor, but there are two common interpretations:</p> <ol> <li>Zip-like behavior: Pair up elements positionally (less common).</li> <li>Cartesian product: Apply the function to all combinations (more common).</li> </ol> <p>Here\u2019s the Cartesian product version:</p> <pre><code>module ListApplicative = struct\n  type 'a t = 'a list\n\n  let pure x = [x]\n\n  let apply fs xs =\n    List.concat_map (fun f -&gt; List.map (fun x -&gt; f x) xs) fs\nend\n</code></pre>"},{"location":"Modules/applicative/#usage_1","title":"Usage","text":"<pre><code>let fs = ListApplicative.pure (fun x -&gt; x + 1)  (* [fun x -&gt; x + 1] *)\nlet xs = [1; 2; 3]\nlet result = ListApplicative.apply fs xs        (* [2; 3; 4] *)\n\nlet fs2 = [((+) 1); ((+) 2)]\nlet xs2 = [10; 20]\nlet result2 = ListApplicative.apply fs2 xs2     (* [11; 21; 12; 22] *)\n</code></pre> <p>Here, <code>apply</code> applies every function in the <code>fs</code> list to every value in the <code>xs</code> list, producing all possible combinations.</p>"},{"location":"Modules/applicative/#comparison-to-functors-and-monads","title":"Comparison to Functors and Monads","text":"<ul> <li>Functor: Only provides <code>map</code> (e.g., <code>List.map</code>, <code>Option.map</code>), which applies a regular function <code>'a -&gt; 'b</code> to a wrapped value <code>'f 'a</code> to get <code>'f 'b</code>.</li> <li>Applicative Functor: Adds <code>pure</code> and <code>apply</code>, allowing functions wrapped in the context (<code>'f ('a -&gt; 'b)</code>) to be used.</li> <li>Monad: Even more powerful, with <code>bind</code> (or <code>&gt;&gt;=</code>), which allows the computation to depend on the result of the previous step, unlike applicative functors where operations are independent.</li> </ul> <p>For example, with <code>option</code>:</p> <ul> <li>Functor: <code>Option.map (fun x -&gt; x + 1) (Some 5)</code> \u2192 <code>Some 6</code></li> <li>Applicative: <code>OptionApplicative.apply (Some (fun x -&gt; x + 1)) (Some 5)</code> \u2192 <code>Some 6</code></li> <li>Monad: <code>Option.bind (Some 5) (fun x -&gt; if x &gt; 0 then Some (x + 1) else None)</code> \u2192 <code>Some 6</code></li> </ul> <p>Applicative functors are useful when you want to apply functions in a context without the full power (or complexity) of monads.</p>"},{"location":"Modules/applicative/#conclusion","title":"Conclusion","text":"<p>In OCaml, an applicative functor is typically implemented as a module with a type <code>'a t</code>, a <code>pure</code> function to lift values, and an <code>apply</code> function to combine wrapped functions and values. It\u2019s a flexible abstraction that works well for types like <code>option</code>, <code>list</code>, and others, enabling elegant, context-aware function application. Let me know if you\u2019d like more examples or clarification!</p>"},{"location":"Modules/functor/","title":"Functors","text":""},{"location":"Modules/functor/#what-is-a-functor","title":"What is a functor?","text":"<p>Quotes</p> <p>As suggested by the name, a functor is almost like a function. However, while functions are between values, functors are between modules. A functor has a module as a parameter and returns a module as a result. Ocaml.org</p> <p>A functor is simply a \u201cfunction\u201d from modules to modules Ocaml programming</p> <p>Example</p> <pre><code>module type X = sig\n  val x : int\nend\n\nmodule IncX (M : X) = struct\n  let x = M.x + 1\nend;;\n</code></pre> <p>In the above, <code>IncX</code> is a functor which takes as a parameter a module <code>M</code> with signature <code>X</code>. </p> <p><code>IncX</code> has one variable, <code>x</code>, which has as its value the <code>x</code> value from the input module <code>M</code> incremented by 1.</p> <p>If the above is copied into utop, utop shows the following signatures:</p> <pre><code>module type X = sig val x : int end\nmodule IncX : functor (M : X) -&gt; sig val x : int end\n</code></pre> <p>The functor, IncX, is defined. </p> <p>The type of the input module M has type X. </p> <p>M is not defined, it is a placeholder - for a parameter which is a module. The module that is provided for M must comply with the type signature X.</p> <p>The following defines a module A which complies with type signature X. The value for variable x is set to 0:</p> <p><pre><code>module A = struct \n  let x = 0 \nend;;\n</code></pre> A.x is 0. </p> <p>If IncX is applied to A it produces a new module:</p> <pre><code>module B = IncX (A);;\n</code></pre> <p>The module returned by applying the functor IncX to module A has the x value of A incremented by 1.</p> <pre><code>utop # A.x;;\n- : int = 0\n\nutop # B.x;;\n- : int = 1\n</code></pre>"},{"location":"Modules/make/","title":"The 'Make' design pattern","text":""},{"location":"Modules/modules/","title":"Basic modules","text":""},{"location":"Modules/modules/#defining-a-module","title":"Defining a module","text":"<p>Examples</p> <p><pre><code>(* Defining a module type *)\nmodule type Myarith = sig\n  type t\n  val myadd int -&gt; int\n  val mysub int -&gt; int\nend\n</code></pre> <pre><code>(* Defining a module struct *)\nmodule Myarith = struct\n  let myadd x y = x + y\n  let mysub x y = x - y\nend\n</code></pre></p>"},{"location":"Modules/modules/#module-types","title":"Module types","text":"<p>Quotes</p> <p>The implementation details of a module can be hidden by attaching an interface. (Note that in the context of OCaml, the terms interface, signature, and module type are all used interchangeably.) Real World Ocaml</p> <p>Understanding</p> <p>The module type is used to control what parts of the module are exposed.</p> <p>The module struct can have additional declarations in it but if they are not included in the type signature they will not be exposed (for example to utop).</p> <p>Examples</p> <pre><code>(* Defining a module type using : after the module name *)\nmodule Mymod: sig\n  ...\nend = struct\n  ...\nend\n\n(* Defining a module type separately *)\nmodule type S = sig\n  ...\nend\n\nmodule Mymod: S = struct\n  ...\nend\n</code></pre>"},{"location":"Modules/modules/#using-a-module","title":"Using a module","text":""},{"location":"Modules/modules/#accessing-and-using-a-module-in-a-ml-file","title":"Accessing and using a module in a <code>.ml</code> file","text":"<p>[Refer to configuring dune]</p>"},{"location":"Modules/modules/#use-the-module-name","title":"Use the module name","text":"<p>Use the module name and dot notation to access its variables and functions <pre><code>let test = Mymodule.mymodule_var1\n</code></pre></p>"},{"location":"Modules/modules/#open-the-module","title":"Open the module","text":"<p>Its variables and functions are available to the current module. <pre><code>open Mymodule\n\nlet test = mymodule_var1\n</code></pre></p>"},{"location":"Modules/modules/#open-the-module-locally","title":"Open the module locally","text":"<p>It will only be available to the local scope, which is defined by <code>in expr</code> or by <code>.(...)</code> <pre><code>let open Mymodule in ...\n\n(* or *)\nMymodule.(....)\n</code></pre></p>"},{"location":"Modules/modules/#in-utop","title":"In utop","text":"<pre><code>#require \"mymodule\";;\nopen Mymodule;;\n</code></pre>"},{"location":"Modules/modules/#abstract-data-types","title":"Abstract Data Types","text":"<p>Example</p> <p>Longer examples are easier in utop if the code is  written in a file which is then used in utop.</p> <p>The following code is saved in <code>test.ml</code> <pre><code>module Mymod: sig\n  type t\n  val x: (t * t)\n  val add: t -&gt; t -&gt; t\nend = struct\n  type t = int\n  let x = (1,2)\n  let add x y = x + y \nend\n</code></pre> In utop:</p> <p><pre><code>#use \"test.ml\";;\nopen Mymod;;\n\nlet z = Mymod.add 1 2;;\n</code></pre> utop does not accept the first argument: <pre><code>Error: This expression has type int but an expression \nwas expected of type t\n</code></pre> What is the signature of <code>Mymod.x</code>?</p> <p><pre><code>Mymod.x;;\n - : t * t = (&lt;abstr&gt;, &lt;abstr&gt;)\n</code></pre> Type <code>t</code> is an abstract type. utop does not know it is an integer under the hood.</p>"},{"location":"Modules/modules/#reducing-the-abstraction","title":"Reducing the abstraction","text":""},{"location":"Modules/modules/#1-change-some-types","title":"1. Change some types.","text":"<p>Example</p> <p>Define Mymod.add to take int arguments. Make the arguments concrete types, not abstract types.</p> <p><code>test.ml</code>: <pre><code>module Mymod: sig\n  type t\n  val x: (t * t)\n  val add: int -&gt; int -&gt; t\nend = struct\n  type t = int\n  let x = (1,2)\n  let add x y = x + y \nend\n</code></pre> utop: <pre><code>#use \"test.ml\";;\n\nopen Mymod;;\n\nlet z = Mymod.add 1 2;;\nval z : t = &lt;abstr&gt;\n(* Applying Mymod.add now works but the result is abstract. *)\n</code></pre></p>"},{"location":"Modules/modules/#2-include-an-evaluator","title":"2. Include an evaluator.","text":"<p>Example</p> <p>Add <code>int_of_t</code> to convert the t type to an int.</p> <p><code>test.ml</code>: <pre><code>module Mymod: sig\n  type t\n  val x: (t * t)\n  val add: int -&gt; int -&gt; t\n  val int_of_t: t -&gt; int\nend = struct\n  type t = int\n  let x = (1,2)\n  let add x y = x + y \n  let int_of_t x = x \nend\n</code></pre> utop: <pre><code>#use \"test.ml\";;\nopen Mymod;;\n\nlet z = Mymod.add 1 2;;\nval z : t = &lt;abstr&gt;\n\nMymod.int_of_t z;;\n- : int = 3\n</code></pre></p>"},{"location":"Modules/modules/#3-add-a-pretty-printer","title":"3. Add a pretty-printer","text":"<p>Examples</p> <p>A simple pretty-printer, using Format.printf.</p> <p><code>test.ml</code>:</p> <p><pre><code>module Mymod: sig\n  type t\n  val x: (t * t)\n  val add: int -&gt; int -&gt; t\n  val pp: t -&gt; unit \nend = struct\n  type t = int\n  let x = (1,2)\n  let add x y = x + y \n  let pp z = Format.printf \"Pretty printing: %i@.\" z \nend\n</code></pre> utop: <pre><code>#use \"test.ml\";;\nopen Mymod;;\n#install_printer pp;;\n\nlet z = Mymod.add 1 2;;\nPretty printing: 3\nval z : t = \n</code></pre></p> <p>A more complex pretty printer.</p> <p><code>test.ml</code></p> <p><pre><code>module Mymod: sig\n  type t\n  val x: (t * t)\n  val add: int -&gt; int -&gt; t\n  val pp_add: t -&gt; unit \n  val pp_show_tuple: (t * t) -&gt; unit\nend = struct\n  type t = int\n  let x = (1,2)\n  let add x y = x + y \n\n  (* Pretty printer for the add function,\n     showing how to use a formatter using fprintf *)\n\n  (* Define a formatter*)\n  let pp_add_ptr out k = \n    Format.fprintf out \"Result: %i\" k \n\n  (* The pretty printer references the formatter with %a *)\n  (* Note it does not have to pass 'out'. Format.printf is \n      fprintf with std_formatter already passed under the hood. *)\n  let pp_add z = \n    Format.printf \"@[&lt;v&gt;Pretty printing:@;&lt;0 2&gt;%a @]@.\" pp_add_ptr z \n\n  (* Pretty printer for showing a tuple \n     - it does not utilise a formatter *)\n  let pp_show_tuple (a,b) = \n    Format.printf \"Showing x: (%i, %i)@.\" a b\nend\n</code></pre> utop: <pre><code>#use \"test.ml\";;\nopen Mymod;;\n\n#install_printer pp_add;;\n#install_printer pp_show_tuple;;\n\nMymod.x;;\nShowing x: (1, 2)\n- : t * t = \n\nMymod.add 6 7;;\nPretty printing:\n  Result: 13\n</code></pre></p>"},{"location":"Modules/modules/#4-use-ppx_derivingshow","title":"4. Use <code>ppx_deriving.show</code>","text":"<p>References</p> <p>Real World Ocaml Stackoverflow Ocaml Programming - type constraints Ocaml Programming - encapsulation How does one print any type?</p>"},{"location":"Modules/monads/","title":"Monads","text":"<p>A monad is a design pattern. </p>"},{"location":"Modules/monads/#monad-signature","title":"Monad signature","text":"<p>A monad has the signature:</p> <p><pre><code>  module type Monad = sig\n    type 'a t\n    val return : 'a -&gt; 'a t\n    val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t\n  end\n</code></pre> From this signature:</p> <ul> <li> <p>the type of the monad is defined to be <code>'a t</code>. This is a parameterised type, having the constructor type <code>t</code> and a parameter <code>'a</code> meaning any type.</p> </li> <li> <p>the <code>return</code> function takes a type <code>'a</code> and returns a Monad type<code>'a t</code>.</p> </li> <li> <p>the <code>bind</code> function: </p> <ul> <li> <p>takes 2 parameters:</p> <ul> <li>the first parameter has the Monad type <code>'a t</code></li> <li>the second parameter is a function which is applied to <code>'a</code>, the unwrapped original first parameter, and returns a type <code>'b t</code> (which is compatible with the type of the 'Monad' module but the type parameter can be different to <code>'a</code>)</li> </ul> </li> <li> <p>returns the value of type <code>'b t</code></p> </li> </ul> </li> </ul> <p>A monad takes a value, wraps it in a more complex type so that it contains more information, performs a function on the original value and returns a value of the more complex type holding additional information.</p> <p>In imperative languages, this additional information, which might be some form of state, is tracked outside of functions by using variables. A monad is useful in functional programming for holding additional information while maintaining the functional paradigm.</p> <p>Quote 1</p> <p>More exactly, a monad can be used where unrestricted access to a value is inappropriate for reasons specific to the scenario. In the case of the Maybe monad, it is because the value may not exist. In the case of the IO monad, it is because the value may not be known yet, such as when the monad represents user input that will only be provided after a prompt is displayed. In all cases the scenarios in which access makes sense are captured by the bind operation defined for the monad; for the Maybe monad a value is bound only if it exists, and for the IO monad a value is bound only after the previous operations in the sequence have been performed. </p> <p>Wikipedia</p> <p>Quote 2</p> <p>Say I write an evaluator in a pure functional language.</p> <ul> <li>To add error handling to it, I need to modify each recursive call to check for and handle errors appropriately. Had I used an impure language with exceptions, no such restructuring would be needed.</li> <li>To add a count of operations performed to it, I need to modify each recursive call to pass around such counts appropriately. Had I used an impure language with a global variable that could be incremented, no such restructuring would be needed.</li> <li>To add an execution trace to it, I need to modify each recursive call to pass around such traces appropriately. Had I used an impure language that performed output as a side effect, no such restructuring would be needed.</li> </ul> <p>Or I could use a monad.</p> <p>Philip Wadler</p>"},{"location":"Modules/monads/#monad-example","title":"Monad example","text":"<p>Writer monad</p> <p>The Writer monad can be used to write logs while evaluating functions.</p> <p><pre><code>(* The monad signature *)\nmodule type Monad = sig\n  type 'a t\n  val return : 'a -&gt; 'a t\n  val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t\n  val ( let* ): 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t \nend;;\n\n(* The function to log written as fun *)\n(fun x -&gt; x + 7);;\n\n(* The same function written as a named function *)\nlet myfunction x = x + 7;;\n\n(* The writer monad *)\nmodule Writer: (Monad with type 'a t = 'a * string) = \nstruct\n  type 'a t = 'a * string\n  let return x = (x, \"\")\n  let bind m f =\n    let (x, s1) = m in\n    let (y, s2) = f x in\n    (y, s1 ^ s2) \n  let ( let* ) m f = bind m f \nend;;\n\n(* The type of the Writer monad is a tuple containing two elements:\n   - a value of any type\n   - a string for logging *)\n\n(* Using the monad *)\nopen Writer;;\n\n(* - using Writer.bind and fun *)\nbind (10, \"Param is 10; \") (fun x -&gt; (x + 7, \"Function is x + 7\"));;\n\n(* - using let* syntax *)\nlet* x = (10, \"Param is 10; \") in\n(myfunction x, \"Function is x + 7\");;\n\n(* Compare original code with the monad form *)\n\n(* Original *)\nlet result =\n  let x = 10 in\n  myfunction x;;\n\n(* Using the monad for logging *)\nlet result = \n  let* x = (10, \"Param is 10; \") in\n  (myfunction x, \"Function is x + 7\");;\n</code></pre> The code above more succintly for copying to utop:</p> <pre><code>module type Monad = sig\n  type 'a t\n  val return : 'a -&gt; 'a t\n  val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t\n  val ( let* ): 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t \nend\n\nmodule Writer: (Monad with type 'a t = 'a * string) = \n  struct\n    type 'a t = 'a * string\n    let return x = (x, \"\")\n    let bind m f =\n      let (x, s1) = m in\n      let (y, s2) = f x in\n      (y, s1 ^ s2) \n    let ( let* ) m f = bind m f \n  end\n\nopen Writer\n\n(* Orginal function *)\nlet myfunction x = x + 7;;\n\n(* Logged function *)\nlet* x = (10, \"first logging phrase; \") in\n(myfunction x, \"another logging phrase\");;\n</code></pre>"},{"location":"Modules/monads/#let-syntax","title":"let* syntax","text":"<p>Understanding let* syntax</p> <p>Using the Writer monad example above: </p> <p>The function to be logged: <pre><code>let myfunction x = x + 7;;\n</code></pre> If a specified value, <code>10</code>, was to be passed to <code>myfunction</code> for <code>x</code> we could write: <pre><code>let x = 10 in\nmyfunction x;;\n</code></pre> Using the monad and <code>let*</code> we write: <pre><code>let* x = (10, \"first logging phrase; \") in\n(myfunction x, \"another logging phrase\");;\n</code></pre> Clearly, both examples above are similar except that the second example provides logging.</p> <p><code>let* x</code> extracts the value of type <code>'a</code> from the <code>'a t</code> parameter, the function is applied to it and a value of type <code>'b t</code> is returned.</p>"},{"location":"Printing/debugging/","title":"Using print statements when debugging","text":""},{"location":"Printing/debugging/#inserting-into-code","title":"Inserting into code","text":"<p>Examples</p> <p><pre><code>(* Open the Printf module *)\nopen Printf\n</code></pre> <pre><code>(* Insert a print statement at the top level of the module's code *)\nlet () = printf \"got to here\\n\"\n\n(* Insert a print statement into a local scope *)\n... in\nlet () = printf \"got to here\\n\" in\n...\n</code></pre> <pre><code>(* Print inside an if-else statement *)\nlet a = 0\n\nlet x =  (* original x *)\n  if a = 0 then 5\n  else 6    \n\nlet x = (* using printf to see if branch gets called *)\n  if a = 0 then let () = printf \"here\\n\" in 5\n  else 6\n</code></pre></p>"},{"location":"Printing/debugging/#printing-a-list","title":"Printing a list","text":"<p>Examples</p> <pre><code>open Printf                             (* or open Format *)\n\n(* Printer for an integer list *)       \nlet pp_int_list fmt ls =                (* By convention pretty-printers are prefixed with pp_ *)\n  fprintf fmt \"[\";                      (* Print the opening bracket *)\n  List.iteri (fun i x -&gt;                (* Iterate through the list using the index and the value of each list element *)\n    if i &gt; 0 then fprintf fmt \"; \";     (* Before printing the next list element print a semi-colon and a space *)\n    fprintf fmt \"%d\" x) ls;             (* Print the list's integer element *)\n  fprintf fmt \"]\"                       (* Print the closing bracket *)\n\nlet my_test_list = [1;2;3;4;5]\nlet () = printf \"my_test_list: %a@.\" pp_int_list my_test_list\n\n(* The above prints: *)\nmy_test_list: [1; 2; 3; 4; 5] \n</code></pre>"},{"location":"Printing/debugging/#printing-a-table-from-a-list-of-string-lists","title":"Printing a table from a list of string lists","text":"<p>Examples</p> <pre><code>open Format \n\n(* Printer for printing a table from a string list *)\nlet pp_table fmt ls =\n  print_flush ();\n  open_vbox 0;\n  open_tbox ();\n  fprintf fmt \"  \"; set_tab (); \n  printf  \"First name     \"; set_tab (); \n  printf  \"Second name    \"; set_tab (); \n  printf  \"Address       \"; set_tab (); \n  printf  \"Phone         \"; set_tab (); \n  printf  \"Email    \"; \n  let delim = String.init 65 (fun _ -&gt; '-') in\n  printf \"\\n  %s\" delim;\n  List.iter (fun item -&gt; \n    match item with\n    | [a;b;c;d;e] -&gt;\n      print_tab ();\n      printf \"%s\" a;\n      print_tab ();\n      printf \"%s\" b;\n      print_tab ();\n      printf \"%s\" c; \n      print_tab ();\n      printf \"%s\" d;    \n      print_tab ();\n      printf \"%s\" e;\n    | _ -&gt; printf \"\\nError\\n\";  \n  ) ls;\n  close_tbox ();\n  close_box ();\n  print_flush ()\n\n(* This is the list *)\nlet mylist = \n  [[\"FirstName-0\"; \"SecondName-0\"; \"Address-0\"; \"Phone-0\"; \"Email-0\"]; [\"FirstName-1\"; \"SecondName-1\"; \"Address-1\"; \"Phone-1\"; \"Email-1\"]; [\"FirstName-2\"; \"SecondName-2\"; \"Address-2\"; \"Phone-2\"; \"Email-2\"]; [\"FirstName-3\"; \"SecondName-3\"; \"Address-3\"; \"Phone-3\"; \"Email-3\"]; [\"FirstName-4\"; \"SecondName-4\"; \"Address-4\"; \"Phone-4\"; \"Email-4\"]; [\"FirstName-5\"; \"SecondName-5\"; \"Address-5\"; \"Phone-5\"; \"Email-5\"]; [\"FirstName-6\"; \"SecondName-6\"; \"Address-6\"; \"Phone-6\"; \"Email-6\"]; [\"FirstName-7\"; \"SecondName-7\"; \"Address-7\"; \"Phone-7\"; \"Email-7\"]; [\"FirstName-8\"; \"SecondName-8\"; \"Address-8\"; \"Phone-8\"; \"Email-8\"]; [\"FirstName-9\"; \"SecondName-9\"; \"Address-9\"; \"Phone-9\"; \"Email-9\"]]\n\n(* Print the list using the pp_table pretty-printer *)\nlet () = printf \"%a@.\" pp_table mylist\n</code></pre> <p>This prints:</p> <pre><code>  First name     Second name    Address       Phone         Email\n  -----------------------------------------------------------------\n  FirstName-0    SecondName-0   Address-0     Phone-0       Email-0\n  FirstName-1    SecondName-1   Address-1     Phone-1       Email-1\n  FirstName-2    SecondName-2   Address-2     Phone-2       Email-2\n  FirstName-3    SecondName-3   Address-3     Phone-3       Email-3\n  FirstName-4    SecondName-4   Address-4     Phone-4       Email-4\n  FirstName-5    SecondName-5   Address-5     Phone-5       Email-5\n  FirstName-6    SecondName-6   Address-6     Phone-6       Email-6\n  FirstName-7    SecondName-7   Address-7     Phone-7       Email-7\n  FirstName-8    SecondName-8   Address-8     Phone-8       Email-8\n  FirstName-9    SecondName-9   Address-9     Phone-9       Email-9\n</code></pre>"},{"location":"Printing/format/","title":"Format module","text":"<p>References</p> <p>Ocaml manual: Format module, Format tutorial Format Unraveled Pretty Printing in Ocaml </p> <p>Annotations (Ocaml manual) <pre><code>\"@[\"        open a box (open_box 0).\n\"@[&lt;v n&gt;\"   open a vertical box with an offset of n\n\"@]\"        close a box (close_box ()).\n\"@ \"        output a breakable space (print_space ()).\n\"@,\"        output a break hint (print_cut ()).\n\"@;&lt;n m&gt;\"   emit a \"full\" break hint (print_break n m).\n            n is width\n            m is offset\n            If line is broken then offset is added to the indentation of the current\n            box else (the value of) width blanks are printed.\n\"@.\"        end the pretty-printing, closing all the boxes still opened (print_newline ()).   \n</code></pre> Box types <pre><code>h   horizontal \nv   vertical\nhv  horizontal/vertical \nb   horizontal-or-vertical, demonstrating indentation\nhov horizontal-or-vertical\n</code></pre></p>"},{"location":"Printing/format/#printf-prints-to-stdout","title":"printf - prints to stdout","text":"<p>Examples</p> <p>Use utop for all examples.</p> <p>Open the Format module. </p> <pre><code>open Format;;\n</code></pre>"},{"location":"Printing/format/#formatprintf-with-a-conversion-specifier","title":"Format.printf with a conversion specifier","text":"<p><pre><code>printf \"This is a test. It prints %s \\n%!\" \"hello world\";;\n</code></pre> Prints: <pre><code>This is a test. It prints hello world \n</code></pre></p>"},{"location":"Printing/format/#formatprintf-with-pretty-printing-annotations","title":"Format.printf with pretty-printing annotations","text":"<p><pre><code>printf \"@[&lt;v&gt;This is a test.@ It prints @ %s@]@.\" \"hello world\";;\n</code></pre> Prints: <pre><code>This is a test.\nIt prints\nhello world\n</code></pre> <pre><code>printf \"@[&lt;v 2&gt;This is a test.@;It prints:@;&lt;0 2&gt;%s@]@.\" \"hello world\";;\n</code></pre> Prints: <pre><code>This is a test.\n  It prints:\n    hello world\n</code></pre></p>"},{"location":"Printing/format/#fprintf-same-as-printf-but-outputs-on-a-formatter","title":"fprintf - same as printf but outputs on a formatter","text":"<p>Understanding</p> <p><code>fprintf ff fmt arg1 ... argN</code> formats the arguments arg1 to argN according to the format string fmt, and outputs the resulting string on the formatter ff (Reference) </p> <p>In fact <code>printf</code> is defined in <code>format.ml</code> as <code>fprintf</code> outputting to <code>std_formatter</code>: <pre><code>let printf fmt = fprintf std_formatter fmt \n</code></pre></p> <p>formatter</p> <p><pre><code>type formatter = {\n  (* The pretty-printer scanning stack. *)\n  pp_scan_stack : pp_scan_elem Stack.t;\n  (* The pretty-printer formatting stack. *)\n  pp_format_stack : pp_format_elem Stack.t;\n  pp_tbox_stack : tbox Stack.t;\n  (* The pretty-printer semantics tag stack. *)\n  pp_tag_stack : stag Stack.t;\n  pp_mark_stack : stag Stack.t;\n  (* Value of right margin. *)\n  mutable pp_margin : int;\n  (* Minimal space left before margin, when opening a box. *)\n  mutable pp_min_space_left : int;\n  (* Maximum value of indentation:\n    no box can be opened further. *)\n  mutable pp_max_indent : int;\n  (* Space remaining on the current line. *)\n  mutable pp_space_left : int;\n  (* Current value of indentation. *)\n  mutable pp_current_indent : int;\n  (* True when the line has been broken by the pretty-printer. *)\n  mutable pp_is_new_line : bool;\n  (* Total width of tokens already printed. *)\n  mutable pp_left_total : int;\n  (* Total width of tokens ever put in queue. *)\n  mutable pp_right_total : int;\n  (* Current number of open boxes. *)\n  mutable pp_curr_depth : int;\n  (* Maximum number of boxes which can be simultaneously open. *)\n  mutable pp_max_boxes : int;\n  (* Ellipsis string. *)\n  mutable pp_ellipsis : string;\n  (* Output function. *)\n  mutable pp_out_string : string -&gt; int -&gt; int -&gt; unit;\n  (* Flushing function. *)\n  mutable pp_out_flush : unit -&gt; unit;\n  (* Output of new lines. *)\n  mutable pp_out_newline : unit -&gt; unit;\n  (* Output of break hints spaces. *)\n  mutable pp_out_spaces : int -&gt; unit;\n  (* Output of indentation of new lines. *)\n  mutable pp_out_indent : int -&gt; unit;\n  (* Are tags printed ? *)\n  mutable pp_print_tags : bool;\n  (* Are tags marked ? *)\n  mutable pp_mark_tags : bool;\n  (* Find opening and closing markers of tags. *)\n  mutable pp_mark_open_tag : stag -&gt; string;\n  mutable pp_mark_close_tag : stag -&gt; string;\n  mutable pp_print_open_tag : stag -&gt; unit;\n  mutable pp_print_close_tag : stag -&gt; unit;\n  (* The pretty-printer queue. *)\n  pp_queue : pp_queue;\n}\n</code></pre> The type <code>formatter</code> is defined in the module's <code>.ml</code> file but not in its <code>.mli</code> (interface) file. In its <code>.mli</code> file it is an abstract type: <pre><code>type formatter\n</code></pre></p>"},{"location":"Printing/format/#examples","title":"Examples","text":"<p>These examples are set out for copying into utop. (<code>;;</code> is used to tell utop to execute code and should be removed if copying into a .ml file)</p> <p>The pattern <code>fprintf out</code> is used for the general case and can often be replaced by <code>printf</code> if printing to std out.</p> <p>fprintf</p> <p>printf</p> <p>The <code>%a</code> modifier</p> <p>List</p> <p>Format convenience functions</p> <p>Table</p>"},{"location":"Printing/format/#basic-using-fprintf","title":"Basic - using fprintf","text":"<p><pre><code>let fprintf = Format.fprintf;;\nlet out = Format.std_formatter;;\n\nlet pp_string out string = fprintf out \"%S\" string;;\npp_string out \"test\";;\n</code></pre> Explanation:</p> <ul> <li><code>fprintf</code> takes a formatter, in this case the formatter for standard output is used</li> </ul>"},{"location":"Printing/format/#basic-using-printf","title":"Basic - using printf","text":"<p><pre><code>let printf = Format.printf;;\n\nlet pp_string string = printf \"%S\" string;;\npp_string \"test\";;\n</code></pre> Explanation:</p> <ul> <li><code>printf</code> assumes the formatter for standard output</li> </ul>"},{"location":"Printing/format/#basic-using-the-a-modifier-for-inserting-a-user-printer","title":"Basic - using the <code>%a</code> modifier for inserting a user-printer","text":"<pre><code>let fprintf = Format.fprintf;;\nlet out = Format.std_formatter;;\n\n(* Define a user-printer *)\nlet pp_printer out string = fprintf out \"%S @.\" string;;\n\n(* Use the user-printer in fprintf *)\nlet my_print out string = fprintf out \"%a @.\" pp_printer string;;\n\n(* Apply it *)\nmy_print out \"testing\";;\n</code></pre>"},{"location":"Printing/format/#printing-a-list","title":"Printing a list","text":"<p>Iterates through list elements. <pre><code>let fprintf = Format.fprintf;;\nlet out = Format.std_formatter;;\n\n(* Define a user-printer *)\nlet print_int_list out ls = \n  fprintf out \"[\";\n  List.iteri\n    (fun i x -&gt;\n    if i &gt; 0 then fprintf out \"; \";\n    fprintf out \"%d\" x ) ls;\n  fprintf out \"]\";;  \n\n(* Apply it *)\nlet () =\n  let ls = [1;2;3;4] in\n  fprintf out \"%a @.\" print_int_list ls;;\n</code></pre> This prints: <pre><code>[1; 2; 3; 4]\n</code></pre> Explanation:</p> <ul> <li>the user-printer is the function <code>print_int_list</code> which takes a formatter and a list</li> <li>it prints the square bracket \"[\"</li> <li>it iterates through the list and prints each element, denoted by x, in the list</li> <li>prior to printing the element it prints \"; \" if the index, i, is greater than zero</li> <li>it prints the square bracket \"]\"</li> </ul> <p>Using <code>printf</code> instead of <code>fprintf</code> is a little simpler, but <code>%a</code> expects the user-printer to provide a formatter.  The user-printer must still use a <code>fprintf</code> but the calling function can use <code>printf</code>, which passes the standard formatter under the hood: <pre><code>(* Define a user-printer *)\nlet print_int_list out ls = \n  fprintf out \"[\";\n  List.iteri\n    (fun i x -&gt;\n    if i &gt; 0 then fprintf out \"; \";\n    fprintf out \"%d\" x ) ls;\n  fprintf out \"]\";;  \n\n(* Apply it *)\nlet () =\n  let ls = [1;2;3;4] in\n  printf \"%a @.\" print_int_list ls;;\n</code></pre></p>"},{"location":"Printing/format/#printing-a-list-using-a-format-convenience-function","title":"Printing a list using a Format convenience function","text":"<p>The convenience function is: Format.pp_print_list. <pre><code>let fprintf = Format.fprintf;;\nlet printf = Format.printf;;\nlet out = Format.std_formatter;;\n\n(* Handler for each element of list *)\nlet print_int out i = fprintf out \"%d\" i;;\n\n(* Define a user-printer *)\nlet print_int_list out ls = \n  let sep out () = fprintf out \";\" in\n  Format.pp_print_list ~pp_sep:sep print_int out ls;;\n\nlet () =\n  let ls = [1;2;3;4] in\n  printf \"[%a] @.\" print_int_list ls;;\n</code></pre></p>"},{"location":"Printing/format/#printing-a-table","title":"Printing a table","text":"<p><pre><code>(* We want to print this list of tuples in a table\n   with each row containing one tuple *)\nopen Format;;\n\nlet stats = [(\"a\",\"b\",\"c\");(\"d\",\"e\",\"f\");(\"g\",\"h\",\"i\")];; \n\nlet mytable statistics =\n  open_vbox 0;\n  open_tbox ();\n  printf \"  \"; set_tab (); \n  printf \"Col 1       \"; set_tab (); \n  printf \"Col 2       \"; set_tab (); \n  printf \"Col 3       \";\n  let delim = String.init 30 (fun _ -&gt; '-') in\n  Format.printf \"\\n  %s\" delim;\n  List.iter (fun (x, y, z) -&gt; \n    print_tab ();\n    printf \"%s\" x;\n    print_tab ();\n    printf \"%s\" y;\n    print_tab ();\n    printf \"%s\" z;    \n  ) statistics;\n  close_tbox ();\n  close_box ();\n  print_flush ();\n  print_newline ()\n  ;;\n\nlet () = mytable stats;;\n</code></pre> This prints: <pre><code>  Col 1       Col 2       Col 3       \n  ------------------------------\n  a           b           c\n  d           e           f\n  g           h           i\n</code></pre> Explanation:</p> <ul> <li>open a tabulation box</li> <li>print the table header, setting tabs at same time</li> <li>iterate through the input list of tuples:<ul> <li>move to a tab stop then print a tuple element</li> </ul> </li> <li>close the tabluation box</li> </ul> <p>Comments:</p> <ul> <li>consider PrintBox for more features</li> </ul>"},{"location":"Printing/print/","title":"Simple printing","text":"<p>Examples</p> <p>In utop: <pre><code>print_endline \"a string\";;\nprint_char 'c';;\nprint_string \"a string\";;\nprint_int 5;;\nprint_float 2.5;;\n</code></pre></p>"},{"location":"Printing/print/#printf-module","title":"Printf module","text":""},{"location":"Printing/print/#conversion-specification","title":"Conversion specification","text":"<p>See the full conversion specification in the manual.</p> <p>Examples</p> <p>Formatting and printing to standard output <pre><code>Printf.printf \"There are %i %s \\n%!\" 15 \"apples\";; \n(* Prints: There are 15 apples *)\n\nlet x = 20;;\nPrintf.printf \"There are %i %s \\n%!\" x \"bananas\";;\n(* Prints: There are 20 bananas *)\n\nPrintf.printf \"%#016x \\n%!\" 255;; \nPrintf.printf \"%#016x \\n%!\" 0xff;;\n(* Each of these prints: 0x000000000000ff *)\n(* Explanation:\n   #: 0x prefix \n   0: padding\n  16: width \n   x: hexadecimal\n  \\n: line\n  %!: flush buffer *)\n</code></pre> Returning a formatted string rather than printing it using sprintf <pre><code>let x = 20;;\nlet mystring = Printf.sprintf \"There are %i bananas \\n%!\" x;;\n</code></pre></p>"},{"location":"Printing/print/#escape-sequences","title":"Escape sequences","text":"<p>https://ocaml.org/manual/latest/lex.html</p> Sequence Character denoted \\ backslash () \\\" double quote (\") \\' single quote (') \\n linefeed (LF) \\r carriage return (CR) \\t horizontal tabulation (TAB) \\b backspace (BS) \\space space (SPC) \\ddd the character with ASCII code ddd in decimal \\xhh the character with ASCII code hh in hexadecimal \\oooo the character with ASCII code ooo in octal"},{"location":"Running/compile/","title":"Compiling","text":""},{"location":"Running/compile/#bytecode","title":"Bytecode","text":"<ul> <li>an instruction set designed for execution by an interpreter (Wikipedia)</li> <li>the Ocaml interpreter is ocamlrun</li> <li>compiled by <code>ocamlc</code></li> <li>Ref, Ref</li> </ul> <p>Arguments used by ocamlc - a good description in ocamlfind docs</p> Argument Description .mli Source files for compilation unit interfaces. From the file x.mli, the ocamlc compiler produces a compiled interface in the file x.cmi .ml Source files for compilation unit implementations. From the file x.ml, the ocamlc compiler produces compiled object bytecode in the file x.cmo .cmo Compiled object bytecode. These files are linked together, along with the object files obtained by compiling .ml arguments (if any), and the OCaml standard library, to produce a standalone executable program. .cma Libraries of object bytecode or plugin bytecode(loaded at rutime). A library packs in a single file a set of object bytecode files (.cmo files) -o exec-file The name of the output file produced by the compiler (default: a.out under Unix and camlprog.exe under Windows) <p>Output</p> <ul> <li>If <code>a.out</code> is the name of the file produced by the linking phase, the command <code>ocamlrun a.out arg1 arg2 \u2026 argn</code> executes the compiled code contained in <code>a.out</code></li> <li>On most systems, the file produced by the linking phase can be run directly, as in: <code>./a.out arg1 arg2 \u2026 argn</code></li> </ul>"},{"location":"Running/compile/#native-code","title":"Native code","text":"<ul> <li>also called machine code</li> <li>machine language which is executed directly on computer's CPU</li> <li>therefore hardware-CPU dependent </li> <li>compiled by <code>ocamlopt</code></li> <li>Ref, Ref, Ref</li> </ul> <p>Arguments used by ocamlopt</p> Argument Description .mli Source files for compilation unit interfaces. From the file x.mli, the ocamlopt compiler produces a compiled interface in the file x.cmi. .ml Source files for compilation unit implementations. From the file x.ml, the ocamlopt compiler produces: x.o, containing native object code, and x.cmx, containing extra information for linking and optimization. .cmx compiled object code .cmxa libraries of object code .cmxs plugin (loaded at runtime -o exec-file the name of the output file produced by the linker (default: a.out under Unix and camlprog.exe under Windows) .cmt, cmti \"The compiler is able to emit some information on its internal stages. It can output .cmt files for the implementation of the compilation unit and .cmti for signatures if the option -bin-annot is passed to it (see the description of -bin-annot below). Each such file contains a typed abstract syntax tree (AST), that is produced during the type checking procedure. This tree contains all available information about the location and the specific type of each term in the source file. The AST is partial if type checking was unsuccessful. These .cmt and .cmti files are typically useful for code inspection tools.\" Ref <p>Output</p> <ul> <li>The output of the linking phase is a regular Unix or Windows executable file. It does not need ocamlrun to run.</li> </ul> <p>References</p> <p>Compiling to Assembly from Scratch</p>"},{"location":"Running/dune/","title":"Build with dune","text":"<p>References</p> <p>Getting started with OCaml</p> <p>Recipes</p>"},{"location":"Running/dune/#create-a-project","title":"Create a project","text":"<pre><code># Create a folder, myproject, containing a project skeleton\ndune init proj myproject\n\n# Move into the root folder of the project to work on it\ncd myproject\n</code></pre>"},{"location":"Running/dune/#build-the-project","title":"Build the project","text":"<p>Create a folder, <code>_build</code>, containing the compiled executable. <pre><code>dune build\n</code></pre></p>"},{"location":"Running/dune/#run-the-executable","title":"Run the executable","text":"<pre><code>dune exec myproj\n</code></pre>"},{"location":"Running/dune/#clean-the-project","title":"Clean the project","text":"<pre><code>dune clean\n</code></pre>"},{"location":"Type%20system/builtin/","title":"Predefined types","text":"<p>Type definitions that are built into Ocaml.</p>"},{"location":"Type%20system/builtin/#primitives","title":"Primitives","text":"<p>A primitive cannot be contructed from other types</p> Value is Type Example value an integer <code>int</code> <code>5</code> a float <code>float</code> <code>5.</code> a character <code>char</code> <code>'c'</code> a string <code>string</code> <code>\"the\"</code> a boolean <code>bool</code> <code>true</code><code>false</code>"},{"location":"Type%20system/builtin/#data-structures","title":"Data structures","text":"Value is Type Example value Comment a tuple <code>'a * 'b *'c</code><code>int * string</code> <code>(anytype, anytype, anytype)</code><code>(12, \"the\")</code> a list <code>'a list</code><code>int list</code><code>string list</code> <code>[sametype; sametype; sametype]</code><code>[1;2;3]</code><code>[\"apples\";\"oranges\";\"bananas\"]</code> Size is mutable. Elements are immutable. an array <code>'a array</code><code>int array</code><code>string array</code> <code>[|sametype; sametype; sametype |]</code><code>[|1;2;3|]</code><code>[|\"apples\";\"oranges\";\"bananas\"|]</code> Size is fixed. Elements are mutable <p>Understanding <code>int list</code></p> <p>The following help to understand <code>int list</code>:</p> <ul> <li>The type of an integer list is neither <code>int</code> nor <code>list</code> but <code>int list</code> </li> <li><code>int</code> is a type parameter</li> <li>It is a composite type, constructed using the list type constructor, which takes a base type (the primitive, int) and produces a new type (int list).</li> <li>An integer type is wrapped into a list   </li> <li>The type is a list with elements of type <code>int</code></li> </ul>"},{"location":"Type%20system/gadt/","title":"Generalized Algebraic Datatypes (GADT)","text":"<p>References</p> <p>Ocaml manual</p>"},{"location":"Type%20system/parameterised/","title":"Parameterised types","text":"<p>Ocaml manual</p> <p>The optional type parameters are either one type variable <code>'ident</code>, for type constructors with one parameter, or a list of type variables (<code>'ident1,\u2026,'identn</code>), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint <code>+</code> (resp. <code>-</code>) indicating that the parameter is covariant (resp. contravariant), and an injectivity annotation <code>!</code> indicating that the parameter can be deduced from the whole type. </p> <p>Examples</p> <p>Parameterised types with single type variables: <pre><code>type int List\ntype 'a List\ntype 'a t\n</code></pre> Two variables as type parameters: <pre><code>type ('a, 'b) disj = Left of 'a | Right of 'b\n</code></pre></p>"},{"location":"Type%20system/polymorphic/","title":"Polymorphic variants","text":"<ul> <li>Can use them without declaring them first</li> <li>They are anonymous types</li> <li>Constructors ('tags') start with a back tick</li> </ul> <p>Examples</p> <pre><code>let plus x y = `Plus (x,y)\nmatch plus 5 7 with | `Plus (a,b) -&gt; a + b (* returns: 12 *);;\n</code></pre>"},{"location":"Type%20system/understand/","title":"Understanding types","text":""},{"location":"Type%20system/understand/#why-have-types","title":"Why have types?","text":"<p>Data is held in memory. A compiler needs to have information about how to use what is held in memory. A value has an associated type (or data type).</p> <p>Quotes</p> <p>Type: something that defines a set of possible values and a set of operations for an object. C++</p> <p>The type of a value defines the interpretation of the memory holding it and the operations that may be performed on the value. Rust</p> <p>Type: A collection of values. An estimate of the collection of values that a program fragment can assume during program execution.Cardelli</p> <p>If V is the set of all values then a type is a subset of V, with values that have technical properties. The phrase having a type is then interpreted as membership in the appropriate set. Cardelli (paraphrased)</p> <p>The fundamental purpose of a type system is to prevent the occurrence of execution errors during the running of a program. Cardelli</p> <p>... a type is defined by specifying three things:</p> <ul> <li>a name for the type,</li> <li>the values of the type, and</li> <li>the operations that may be performed on values of the type. Harper</li> </ul>"},{"location":"Type%20system/understand/#static-and-dynamic-type-checking","title":"Static and dynamic type checking","text":"<p>In simple terms, code is compiled into an executable. The executable is then distributed to users as a program. A user runs the program.</p> <p>In static type-checking, type information is used at compile time when compiling the executable. The code will not compile if there are type errors. Type information is discarded once code is compiled. There is no type information at run time.</p> <p>In dynamic type-checking, type information is used at run time when the program is run. Because types are checked at run time, dynamically typed code runs slower than statically typed code.</p> <p>Ocaml is statically typed. Ocaml code will not compile if there are type errors. Type information is discarded once the executable is compiled. </p>"},{"location":"Type%20system/user/","title":"User-defined types","text":"<p>The type is defined by the user.</p>"},{"location":"Type%20system/user/#records","title":"Records","text":"<p>Examples</p> <pre><code>type car = {maker:string; model:string; year:int};; \nlet mycar = {maker = \"Mazda\"; model = \"CX-5\"; year = 2020};;\n</code></pre>"},{"location":"Type%20system/user/#variants","title":"Variants","text":"<p>A variant value is one of alternatives. Each alternative is separated by the pipe operator.</p> <p>A variant type is defined: <pre><code>type [name] = [constructor] | [constructor] ...\n</code></pre></p> <p>Examples</p> <pre><code>(* Enumerated constants *)\ntype fruit = Apple | Pear | Banana;;\nlet myfruit = Apple;;\n\n(* Built-in option type *)\ntype 'a option = Some of 'a | None;;\n\n(* Built-in list type *)\ntype 'a list = [] | ( :: ) of 'a * 'a list;;\n\ntype colour =\n  | Red | Green | Blue | Yellow | Black | White\n  | RGB of {r : int; g : int; b : int};;\nlet mycolour = RGB {r = 125; g = 50; b = 255};;  \n</code></pre>"},{"location":"Type%20system/Signatures/cmdliner/","title":"Example 1: <code>cmdliner</code>","text":"<p><code>cmdliner</code> is a library for wrapping a CLI command in additional information relating to its documentation. When the executable is run with <code>--help</code> it displays a man (manual) page. If the executable is run without the appropriate arguments a short help will be displayed.</p> <p>References</p> <p>cmdliner tutorial, documentation and api  cmdliner source code</p> <p>The following is an example of a command-line tool <code>chorus</code> that is provided in the tutorial.</p> <p>The tool will take a message <code>MSG</code> and print it <code>COUNT</code> times. The help for the tool  will look like:</p> <pre><code>chorus [-c COUNT | --count=COUNT] [MSG]\n</code></pre> <p>From the tutorial</p> <p>With Cmdliner your tool's main function evaluates a command.</p> <p>A command is a value of type <code>Cmdliner.Cmd.t</code> which gathers a command name and a term of type <code>Cmdliner.Term.t</code>. A term is an expression to be evaluated. The type parameter of the term (and the command) indicates the type of the result of the evaluation.</p> <p>One way to create terms is by lifting regular OCaml values with <code>Cmdliner.Term.const</code>. Terms can be applied to terms evaluating to functional values with <code>Cmdliner.Term.($)</code>.</p> <p>chorus.ml</p> <pre><code>(* The chorus tool *)\nlet chorus count msg = \n  for i = 1 to count do \n    print_endline msg \n  done\n\nopen Cmdliner    \n\n(* The tool's arguments *)\n\nlet count =\n  let doc = \"Repeat the message $(docv) times.\" in\n  Arg.(value &amp; opt int 10 &amp; info [\"c\"; \"count\"] ~docv:\"COUNT\" ~doc)\n\nlet msg =\n  let env =\n    let doc = \"Overrides the default message to print.\" in\n    Cmd.Env.info \"CHORUS_MSG\" ~doc\n  in\n  let doc = \"The message to print.\" in\n  Arg.(value &amp; pos 0 string \"Revolt!\" &amp; info [] ~env ~docv:\"MSG\" ~doc)\n\n(* chorus is applied to count &amp; msg with each being of type Term.t *)\nlet chorus_t = Term.(const chorus $ count $ msg)  \n\n(* The command that is evaluated by Cmd.eval in the main function *)\nlet cmd =\n  let doc = \"print a customizable message repeatedly\" in\n  let man = [\n    `S Manpage.s_bugs;\n    `P \"Email bug reports to &lt;bugs@example.org&gt;.\" ]\n  in\n  let info = Cmd.info \"chorus\" ~version:\"%\u200c%VERSION%%\" ~doc ~man in\n  Cmd.v info chorus_t\n\n(* The main function *)\nlet main () = exit (Cmd.eval cmd)\nlet () = main ()\n</code></pre> <p>Copying and pasting each value above into utop show the following signatures:</p> <p><pre><code>val chorus : int -&gt; string -&gt; unit = &lt;fun&gt;\nval count : int Term.t = &lt;abstr&gt;\nval msg : string Term.t = &lt;abstr&gt;\nval chorus_t : unit Term.t = &lt;abstr&gt;\nval cmd : unit Cmd.t = &lt;abstr&gt;\nval main : unit -&gt; 'a = &lt;fun&gt;\n</code></pre> These signatures tell us:</p> <ul> <li> <p>the tool \"chorus\" is a function that takes an integer (the <code>count</code> parameter) and a string (the <code>msg</code> parameter) and returns unit.</p> </li> <li> <p>the <code>count</code> value is an abstract value having type <code>int Term.t</code>. According to the tutorial quoted above when it is evaluated it provides a type equivalent to the type's parameter - an <code>int</code>.</p> </li> <li> <p>the <code>msg</code> value is an abstract value having type <code>string Term.t</code>. According to the tutorial quoted above when it is evaluated it provides a type equivalent to the type's parameter - a <code>string</code>.</p> </li> </ul> <p>The line <code>let chorus_t = Term.(const chorus $ count $ msg)</code> needs picking apart.</p> <ul> <li> <p><code>Term.(body)</code> means the module <code>Term</code> is opened locally in the body between the brackets. </p> </li> <li> <p><code>Term.const</code> has type <code>'a -&gt; 'a t</code>.  It takes a type <code>'a</code> and returns a type <code>'a t</code>. In other words it lifts the value with type <code>'a</code> into the Term context. Possibly the identifier 'const' is short for constructor or constraint? It takes a value of type <code>'a</code> and constructs a value of type <code>'a t</code> (or constrains it to that type).</p> </li> <li> <p><code>chorus</code> is a function which takes two parameters, an <code>int</code> and a <code>string</code>.</p> </li> <li> <p><code>Term.const chorus $ count $ msg</code> has the signature of an applicative functor</p> </li> <li>the function <code>chorus</code> is lifted into the Term context by <code>Term.const</code> and applied to <code>count</code> (already type Term.t)</li> <li>the result is applied to <code>msg</code> (already type Term.t)</li> <li>it returns type <code>unit Term.t</code> (plain chorus returns type <code>unit</code>)</li> </ul>"},{"location":"Type%20system/Signatures/introduction/","title":"Reading signatures","text":""},{"location":"Type%20system/Signatures/introduction/#why","title":"Why?","text":"<p>Types and signatures of functions and modules are ubiquitous in Ocaml.</p> <p>Experienced programmers often start with defining types and signatures before coding their implementation. For them, types and signatures are intrinsic to coding and not just a means of avoiding errors.</p> <p>The documentation of Ocaml libraries is comprehensive in documenting types and signatures (though sometimes feels lacking in descriptions of how to use them). Understanding the relevance of types and signatures enhances the usefulness of documentation.</p>"},{"location":"Type%20system/Signatures/introduction/#preliminaries","title":"Preliminaries","text":"<p>The code for modules is usually contained in an<code>.ml</code> file and an <code>.mli</code> file. The <code>.mli</code> file is the interface and contains those types and signatures that are exposed to the user. All other user-defined types are hidden. </p> <p>Types are often abstract. Don't sweat over trying to figure out how an api is implemented just from signatures contained in an API. A deep dive into the relevant <code>.ml</code> file is often necessary.</p>"},{"location":"Understanding/functional/","title":"Functional programming","text":"<p>Functional programming</p> <p>Programming languages support decomposing problems in several different ways:</p> <ul> <li> <p>Most programming languages are procedural: programs are lists of instructions that tell the computer what to do with the program\u2019s input. C, Pascal, and even Unix shells are procedural languages.</p> </li> <li> <p>In declarative languages, you write a specification that describes the problem to be solved, and the language implementation figures out how to perform the computation efficiently. SQL is the declarative language you\u2019re most likely to be familiar with; a SQL query describes the data set you want to retrieve, and the SQL engine decides whether to scan tables or use indexes, which subclauses should be performed first, etc.</p> </li> <li> <p>Object-oriented programs manipulate collections of objects. Objects have internal state and support methods that query or modify this internal state in some way. Smalltalk and Java are object-oriented languages. C++ and Python are languages that support object-oriented programming, but don\u2019t force the use of object-oriented features.</p> </li> <li> <p>Functional programming decomposes a problem into a set of functions. Ideally, functions only take inputs and produce outputs, and don\u2019t have any internal state that affects the output produced for a given input. Well-known functional languages include the ML family (Standard ML, OCaml, and other variants) and Haskell.</p> </li> </ul> <p>...</p> <p>In a functional program, input flows through a set of functions. Each function operates on its input and produces some output. Functional style discourages functions with side effects that modify internal state or make other changes that aren\u2019t visible in the function\u2019s return value. Functions that have no side effects at all are called purely functional. Avoiding side effects means not using data structures that get updated as a program runs; every function\u2019s output must only depend on its input.</p>"},{"location":"Understanding/lambda/","title":"Lambda calculus","text":"<p>Wikipedia Lambda calculus</p> <p>Lambda calculus has played an important role in the development of the theory of programming languages. Functional programming languages implement lambda calculus.</p> <p>Lambda calculus is composed of 3 elements: variables, functions, and applications.</p> Name Syntax Example Explanation Variable &lt;name&gt; x a variable named \"x\" Function \u03bb&lt;parameters&gt;.&lt;body&gt; \u03bbx.x a function with parameter \"x\" and body \"x\" Application &lt;function&gt;&lt;variable or function&gt; (\u03bbx.x)a calling the function \"\u03bbx.x\" with argument \"a\" <p>Examples</p> <pre><code>lambda calculus      Ocaml equivalent  evaluates to\n\n\u03bbx.x                 (fun x -&gt; x)\n(\u03bbx.x) a             (fun x -&gt; x) a     a\n\u03bbx.x\n</code></pre> <p>References</p> <p>Wikipedia lambda calculus  Learn X in Y minutes Lambda calculus  Compared to SML CS 312 Recitation 26</p>"},{"location":"Understanding/logic/","title":"Logic, mathematics, type theory","text":"<p>There is a correspondence between the language of logic and mathematics and the language of types:   Curry-Howard correspondence Type theory, Intuitionistic logic  Fuller explanation of the Curry-Howard correspondance: Ocaml Programming  Haskell: The Curry-Howard isomorphism</p> <p>Wikipedia - Algebraic data type</p> <p>An algebraic data type is a datatype formed from other types.</p> <p>Two common classes of algebraic types are product types (i.e., tuples, and records) and sum types (i.e., tagged or disjoint unions, coproduct types or variant types).</p> <p>The values of a product type typically contain several values, called fields. All values of that type have the same combination of field types. The set of all possible values of a product type is the set-theoretic product, i.e., the Cartesian product, of the sets of all possible values of its field types.</p> <p>The values of a sum type are typically grouped into several classes, called variants. A value of a variant type is usually created with a quasi-functional entity called a constructor. Each variant has its own constructor, which takes a specified number of arguments with specified types. The set of all possible values of a sum type is the set-theoretic sum, i.e., the disjoint union, of the sets of all possible values of its variants. Enumerated types are a special case of sum types in which the constructors take no arguments, as exactly one value is defined for each constructor.</p> <p>Values of algebraic types are analyzed with pattern matching, which identifies a value by its constructor or field names and extracts the data it contains. </p> <p>Tuple example</p> <ul> <li>a tuple is a product type and has the type notation <code>'a * 'b</code></li> <li>a tuple is a cartesian product</li> <li>a tuple is AND logic</li> <li>a tuple comprising an integer and a string contains values that belong to a logical conjunction of the set of integers and set of strings </li> </ul> <p>Variant example</p> <ul> <li>a variant is a sum type and has the type notation <code>'a + 'b</code>  [CHECK]</li> <li>a variant is OR logic</li> <li>a variant is sometimes referred to as a 'tagged union' or 'disjoint union'</li> <li>a variant comprises values that belong to a logical disjunction </li> </ul> <p>'Propositions as Types' - Wadler</p> <p>Propositions as Types is a notion with depth. It describes a correspondence between a given logic and a given programming language. At the surface, it says that for each proposition in the logic there is a corresponding type in the programming language\u2014and vice versa. Thus we have</p> <p>propositions as types</p> <p>It goes deeper, in that for each proof of a given proposition, there is a program of the corresponding type\u2014and vice versa. Thus we also have</p> <p>proofs as programs</p> <p>And it goes deeper still, in that for each way to simplify a proof there is a corresponding way to evaluate a program and vice versa. Thus we further have</p> <p>simplification of proofs as evaluation of programs</p>"},{"location":"Understanding/mutability/","title":"Mutability","text":""},{"location":"Understanding/overview/","title":"Understanding - Do I need this?","text":"<p>Probably not!</p> <p>These topics are not needed to know how to code in Ocaml but help with understanding Ocaml. </p> <p>I found having at least a cursory knowledge of lambda calculus and type theory helped me understand the structure of functions and why Ocaml has the types it has.</p> <p>The lambda calculus</p> <p>Type theory.</p>"}]}